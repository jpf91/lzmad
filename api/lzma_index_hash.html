<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.index_hash - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.index_hash</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/index_hash.d -->
Validate Index by using a hash function
<p></p>
Hashing makes it possible to use constant amount of memory to validate
 Index of arbitrary size.
<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">struct <a name="lzma_index_hash"></a><span class="ddoc_psymbol">lzma_index_hash</span>;
</dt>
<dd>Opaque data type to hold the Index hash<p></p>

</dd>
<dt class="d_decl">lzma_index_hash* <a name="lzma_index_hash_init"></a><span class="ddoc_psymbol">lzma_index_hash_init</span>(lzma_index_hash* <i>index_hash</i>, lzma_allocator* <i>allocator</i>);
</dt>
<dd>Allocate and initialize a new lzma_index_hash structure
<p></p>
If <i>index_hash</i> is NULL, a new lzma_index_hash structure is allocated,
 initialized, and a pointer to it returned. If allocation fails, NULL
 is returned.
<p></p>

 If <i>index_hash</i> is non-NULL, it is reinitialized and the same pointer
 returned. In this case, return value cannot be NULL or a different
 pointer than the <i>index_hash</i> that was given as an argument.<p></p>

</dd>
<dt class="d_decl">void <a name="lzma_index_hash_end"></a><span class="ddoc_psymbol">lzma_index_hash_end</span>(lzma_index_hash* <i>index_hash</i>, lzma_allocator* <i>allocator</i>);
</dt>
<dd>Deallocate lzma_index_hash structure<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_hash_append"></a><span class="ddoc_psymbol">lzma_index_hash_append</span>(lzma_index_hash* <i>index_hash</i>, lzma_vli <i>unpadded_size</i>, lzma_vli <i>uncompressed_size</i>);
</dt>
<dd>Add a new Record to an Index hash
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>index</td>
<td valign=top>Pointer to a lzma_index_hash structure</td></tr>
<tr><td valign=top>lzma_vli <i>unpadded_size</i></td>
<td valign=top>Unpadded Size of a Block</td></tr>
<tr><td valign=top>lzma_vli <i>uncompressed_size</i></td>
<td valign=top>Uncompressed Size of a Block</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_DATA_ERROR: Compressed or uncompressed size of the
                Stream or size of the Index field would grow too big.
              - LZMA_PROG_ERROR: Invalid arguments or this function is being
                used when lzma_index_hash_decode() has already been used.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_hash_decode"></a><span class="ddoc_psymbol">lzma_index_hash_decode</span>(lzma_index_hash* <i>index_hash</i>, const ubyte* <i>in_</i>, uint* <i>in_pos</i>, size_t <i>in_size</i>);
</dt>
<dd>Decode and validate the Index field
<p></p>
After telling the sizes of all Blocks with lzma_index_hash_append(),
 the actual Index field is decoded with this function. Specifically,
 once decoding of the Index field has been started, no more Records
 can be added using lzma_index_hash_append().
<p></p>

 This function doesn't use lzma_stream structure to pass the input data.
 Instead, the input buffer is specified using three arguments. This is
 because it matches better the internal APIs of liblzma.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_index_hash* <i>index_hash</i></td>
<td valign=top>Pointer to a lzma_index_hash structure</td></tr>
<tr><td valign=top>ubyte* <i>in_</i></td>
<td valign=top>Pointer to the beginning of the input buffer</td></tr>
<tr><td valign=top>uint* <i>in_pos</i></td>
<td valign=top>in[*<i>in_pos</i>] is the next byte to process</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>in[<i>in_size</i>] is the first byte not to process</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: So far good, but more input is needed.
              - LZMA_STREAM_END: Index decoded successfully and it matches
                the Records given with lzma_index_hash_append().
              - LZMA_DATA_ERROR: Index is corrupt or doesn't match the
                information given with lzma_index_hash_append().
              - LZMA_BUF_ERROR: Cannot progress because *<i>in_pos</i> &gt;= <i>in_size</i>.
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_index_hash_size"></a><span class="ddoc_psymbol">lzma_index_hash_size</span>(const lzma_index_hash* <i>index_hash</i>);
</dt>
<dd>Get the size of the Index field as bytes
<p></p>
This is needed to verify the Backward Size field in the Stream Footer.<p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
