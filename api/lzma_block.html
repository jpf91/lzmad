<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.block - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.block</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/block.d -->
.xz Block handling
<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">struct <a name="lzma_block"></a><span class="ddoc_psymbol">lzma_block</span>;
</dt>
<dd>Options for the Block and Block Header encoders and decoders
<p></p>
Different Block handling functions use different parts of this structure.
 Some read some members, other functions write, and some do both. Only the
 members listed for reading need to be initialized when the specified
 functions are called. The members marked for writing will be assigned
 new values at some point either by calling the given function or by
 later calls to lzma_code().<p></p>

<dl><dt class="d_decl">uint <a name="version_"></a><span class="ddoc_psymbol">version_</span>;
</dt>
<dd>Block format version
<p></p>
To prevent API and ABI breakages if new features are needed in
 the Block field, a version number is used to indicate which
 fields in this structure are in use. For now, version must always
 be zero. With non-zero version, most Block related functions will
 return LZMA_OPTIONS_ERROR.
<p></p>

 Read by:
  - All functions that take pointer to lzma_block as argument,
    including lzma_block_header_decode().
<p></p>

 Written by:
  - lzma_block_header_decode()<p></p>

</dd>
<dt class="d_decl">uint <a name="header_size"></a><span class="ddoc_psymbol">header_size</span>;
</dt>
<dd>Size of the Block Header field
<p></p>
This is always a multiple of four.
<p></p>

 Read by:
  - lzma_block_header_encode()
  - lzma_block_header_decode()
  - lzma_block_compressed_size()
  - lzma_block_unpadded_size()
  - lzma_block_total_size()
  - lzma_block_decoder()
  - lzma_block_buffer_decode()
<p></p>

 Written by:
  - lzma_block_header_size()
  - lzma_block_buffer_encode()<p></p>

</dd>
<dt class="d_decl">int <a name="LZMA_BLOCK_HEADER_SIZE_MIN"></a><span class="ddoc_psymbol">LZMA_BLOCK_HEADER_SIZE_MIN</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="LZMA_BLOCK_HEADER_SIZE_MAX"></a><span class="ddoc_psymbol">LZMA_BLOCK_HEADER_SIZE_MAX</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">lzma_check <a name="check"></a><span class="ddoc_psymbol">check</span>;
</dt>
<dd>Type of integrity Check
<p></p>
The Check ID is not stored into the Block Header, thus its value
 must be provided also when decoding.
<p></p>

 Read by:
  - lzma_block_header_encode()
  - lzma_block_header_decode()
  - lzma_block_compressed_size()
  - lzma_block_unpadded_size()
  - lzma_block_total_size()
  - lzma_block_encoder()
  - lzma_block_decoder()
  - lzma_block_buffer_encode()
  - lzma_block_buffer_decode()<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="compressed_size"></a><span class="ddoc_psymbol">compressed_size</span>;
</dt>
<dd>Size of the Compressed Data in bytes
<p></p>
<b>Encoding:</b><br>
If this is not LZMA_VLI_UNKNOWN, Block Header encoder
 will store this value to the Block Header. Block encoder doesn't
 care about this value, but will set it once the encoding has been
 finished.

<p></p>
<b>Decoding:</b><br>
If this is not LZMA_VLI_UNKNOWN, Block decoder will
 verify that the size of the Compressed Data field matches
 <a name="compressed_size"></a><span class="ddoc_psymbol">compressed_size</span>.
<p></p>

 Usually you don't know this value when encoding in streamed mode,
 and thus cannot write this field into the Block Header.
<p></p>

 In non-streamed mode you can reserve space for this field before
 encoding the actual Block. After encoding the data, finish the
 Block by encoding the Block Header. Steps in detail:
<p></p>

  - Set <a name="compressed_size"></a><span class="ddoc_psymbol">compressed_size</span> to some big enough value. If you don't know
    better, use LZMA_VLI_MAX, but remember that bigger values take
    more space in Block Header.
<p></p>

  - Call lzma_block_header_size() to see how much space you need to
    reserve for the Block Header.
<p></p>

  - Encode the Block using lzma_block_encoder() and lzma_code().
    It sets <a name="compressed_size"></a><span class="ddoc_psymbol">compressed_size</span> to the correct value.
<p></p>

  - Use lzma_block_header_encode() to encode the Block Header.
    Because space was reserved in the first step, you don't need
    to call lzma_block_header_size() anymore, because due to
    reserving, header_size has to be big enough. If it is "too big",
    lzma_block_header_encode() will add enough Header Padding to
    make Block Header to match the size specified by header_size.
<p></p>

 Read by:
  - lzma_block_header_size()
  - lzma_block_header_encode()
  - lzma_block_compressed_size()
  - lzma_block_unpadded_size()
  - lzma_block_total_size()
  - lzma_block_decoder()
  - lzma_block_buffer_decode()
<p></p>

 Written by:
  - lzma_block_header_decode()
  - lzma_block_compressed_size()
  - lzma_block_encoder()
  - lzma_block_decoder()
  - lzma_block_buffer_encode()
  - lzma_block_buffer_decode()<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="uncompressed_size"></a><span class="ddoc_psymbol">uncompressed_size</span>;
</dt>
<dd>Uncompressed Size in bytes
<p></p>
This is handled very similarly to compressed_size above.
<p></p>

 <a name="uncompressed_size"></a><span class="ddoc_psymbol">uncompressed_size</span> is needed by fewer functions than
 compressed_size. This is because <a name="uncompressed_size"></a><span class="ddoc_psymbol">uncompressed_size</span> isn't
 needed to validate that Block stays within proper limits.
<p></p>

 Read by:
  - lzma_block_header_size()
  - lzma_block_header_encode()
  - lzma_block_decoder()
  - lzma_block_buffer_decode()
<p></p>

 Written by:
  - lzma_block_header_decode()
  - lzma_block_encoder()
  - lzma_block_decoder()
  - lzma_block_buffer_encode()
  - lzma_block_buffer_decode()<p></p>

</dd>
<dt class="d_decl">lzma_filter* <a name="filters"></a><span class="ddoc_psymbol">filters</span>;
</dt>
<dd>Array of <a name="filters"></a><span class="ddoc_psymbol">filters</span>
<p></p>
There can be 1-4 <a name="filters"></a><span class="ddoc_psymbol">filters</span>. The end of the array is marked with
 .id = LZMA_VLI_UNKNOWN.
<p></p>

 Read by:
  - lzma_block_header_size()
  - lzma_block_header_encode()
  - lzma_block_encoder()
  - lzma_block_decoder()
  - lzma_block_buffer_encode()
  - lzma_block_buffer_decode()
<p></p>

 Written by:
  - lzma_block_header_decode(): Note that this does NOT free()
    the old filter options structures. All unused <a name="filters"></a><span class="ddoc_psymbol">filters</span>[] will
    have .id == LZMA_VLI_UNKNOWN and .options == NULL. If
    decoding fails, all <a name="filters"></a><span class="ddoc_psymbol">filters</span>[] are guaranteed to be
    LZMA_VLI_UNKNOWN and NULL.

<p></p>
<b>Note:</b><br>
Because of the array is terminated with
              .id = LZMA_VLI_UNKNOWN, the actual array must
              have LZMA_FILTERS_MAX + 1 members or the Block
              Header decoder will overflow the buffer.<p></p>

</dd>
<dt class="d_decl">ubyte[LZMA_CHECK_SIZE_MAX] <a name="raw_check"></a><span class="ddoc_psymbol">raw_check</span>;
</dt>
<dd>Raw value stored in the Check field
<p></p>
After successful coding, the first lzma_check_size(check) bytes
 of this array contain the raw value stored in the Check field.
<p></p>

 Note that CRC32 and CRC64 are stored in little endian byte order.
 Take it into account if you display the Check values to the user.
<p></p>

 Written by:
  - lzma_block_encoder()
  - lzma_block_decoder()
  - lzma_block_buffer_encode()
  - lzma_block_buffer_decode()<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">template <a name="lzma_block_header_size_decode"></a><span class="ddoc_psymbol">lzma_block_header_size_decode</span>(uint b)</dt>
<dd>Decode the Block Header Size field
<p></p>
To decode Block Header using lzma_block_header_decode(), the size of the
 Block Header has to be known and stored into lzma_block.header_size.
 The size can be calculated from the first byte of a Block using this macro.
 Note that if the first byte is 0x00, it indicates beginning of Index; use
 this macro only when the byte is not 0x00.
<p></p>

 There is no encoding macro, because Block Header encoder is enough for that.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_block_header_size"></a><span class="ddoc_psymbol">lzma_block_header_size</span>(lzma_block* <i>block</i>);
</dt>
<dd>Calculate Block Header Size
<p></p>
Calculate the minimum size needed for the Block Header field using the
 settings specified in the lzma_block structure. Note that it is OK to
 increase the calculated header_size value as long as it is a multiple of
 four and doesn't exceed LZMA_BLOCK_HEADER_SIZE_MAX. Increasing header_size
 just means that lzma_block_header_encode() will add Header Padding.

<p></p>
<b>Returns:</b><br>- LZMA_OK: Size calculated successfully and stored to
                <i>block</i>.header_size.
              - LZMA_OPTIONS_ERROR: Unsupported version, filters or
                filter options.
              - LZMA_PROG_ERROR: Invalid values like compressed_size == 0.

<p></p>
<b>Note:</b><br>
This doesn't check that all the options are valid i.e. this
              may return LZMA_OK even if lzma_block_header_encode() or
              lzma_block_encoder() would fail. If you want to validate the
              filter chain, consider using lzma_memlimit_encoder() which as
              a side-effect validates the filter chain.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_block_header_encode"></a><span class="ddoc_psymbol">lzma_block_header_encode</span>(const(lzma_block)* <i>block</i>, ubyte* <i>out_</i>);
</dt>
<dd>Encode Block Header
<p></p>
The caller must have calculated the size of the Block Header already with
 lzma_block_header_size(). If a value larger than the one calculated by
 lzma_block_header_size() is used, the Block Header will be padded to the
 specified size.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer. This must be
                          at least <i>block</i>.header_size bytes.</td></tr>
<tr><td valign=top>const(lzma_block)* <i>block</i></td>
<td valign=top>Block options to be encoded.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Encoding was successful. <i>block</i>.header_size
                bytes were written to output buffer.
              - LZMA_OPTIONS_ERROR: Invalid or unsupported options.
              - LZMA_PROG_ERROR: Invalid arguments, for example
                <i>block</i>.header_size is invalid or <i>block</i>.filters is NULL.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_block_header_decode"></a><span class="ddoc_psymbol">lzma_block_header_decode</span>(lzma_block* <i>block</i>, lzma_allocator* <i>allocator</i>, const(ubyte)* <i>in_</i>);
</dt>
<dd>Decode Block Header
<p></p>
<i>block</i>.version should be set to the highest value supported by the
 application; currently the only possible version is zero. This function
 will set version to the lowest value that still supports all the features
 required by the Block Header.
<p></p>

 The size of the Block Header must have already been decoded with
 lzma_block_header_size_decode() macro and stored to <i>block</i>.header_size.
<p></p>

 <i>block</i>.filters must have been allocated, but they don't need to be
 initialized (possible existing filter options are not freed).

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_block* <i>block</i></td>
<td valign=top>Destination for Block options.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>lzma_allocator for custom <i>allocator</i> functions.
                          Set to NULL to use malloc() (and also free()
                          if an error occurs).</td></tr>
<tr><td valign=top>const(ubyte)* <i>in_</i></td>
<td valign=top>Beginning of the input buffer. This must be
                          at least <i>block</i>.header_size bytes.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Decoding was successful. <i>block</i>.header_size
                bytes were read from the input buffer.
              - LZMA_OPTIONS_ERROR: The Block Header specifies some
                unsupported options such as unsupported filters. This can
                happen also if <i>block</i>.version was set to a too low value
                compared to what would be required to properly represent
                the information stored in the Block Header.
              - LZMA_DATA_ERROR: Block Header is corrupt, for example,
                the CRC32 doesn't match.
              - LZMA_PROG_ERROR: Invalid arguments, for example
                <i>block</i>.header_size is invalid or <i>block</i>.filters is NULL.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_block_compressed_size"></a><span class="ddoc_psymbol">lzma_block_compressed_size</span>(lzma_block* <i>block</i>, lzma_vli <i>unpadded_size</i>);
</dt>
<dd>Validate and set Compressed Size according to Unpadded Size
<p></p>
Block Header stores Compressed Size, but Index has Unpadded Size. If the
 application has already parsed the Index and is now decoding Blocks,
 it can calculate Compressed Size from Unpadded Size. This function does
 exactly that with error checking:
<p></p>

  - Compressed Size calculated from Unpadded Size must be positive integer,
    that is, Unpadded Size must be big enough that after Block Header and
    Check fields there's still at least one byte for Compressed Size.
<p></p>

  - If Compressed Size was present in Block Header, the new value
    calculated from Unpadded Size is compared against the value
    from Block Header.

<p></p>
<b>Note:</b><br>
This function must be called after_ decoding the Block Header
              field so that it can properly validate Compressed Size if it
              was present in Block Header.

<p></p>
<b>Returns:</b><br>- LZMA_OK: <i>block</i>.compressed_size was set successfully.
              - LZMA_DATA_ERROR: <i>unpadded_size</i> is too small compared to
                <i>block</i>.header_size and lzma_check_size(<i>block</i>.check).
              - LZMA_PROG_ERROR: Some values are invalid. For example,
                <i>block</i>.header_size must be a multiple of four and
                between 8 and 1024 inclusive.<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_block_unpadded_size"></a><span class="ddoc_psymbol">lzma_block_unpadded_size</span>(const lzma_block* <i>block</i>);
</dt>
<dd>Calculate Unpadded Size
<p></p>
The Index field stores Unpadded Size and Uncompressed Size. The latter
 can be taken directly from the lzma_block structure after coding a Block,
 but Unpadded Size needs to be calculated from Block Header Size,
 Compressed Size, and size of the Check field. This is where this function
 is needed.

<p></p>
<b>Returns:</b><br>Unpadded Size on success, or zero on error.<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_block_total_size"></a><span class="ddoc_psymbol">lzma_block_total_size</span>(const(lzma_block*) <i>block</i>);
</dt>
<dd>Calculate the total encoded size of a Block
<p></p>
This is equivalent to lzma_block_unpadded_size() except that the returned
 value includes the size of the Block Padding field.

<p></p>
<b>Returns:</b><br>On success, total encoded size of the Block. On error,
              zero is returned.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_block_encoder"></a><span class="ddoc_psymbol">lzma_block_encoder</span>(lzma_stream* <i>strm</i>, lzma_block* <i>block</i>);
</dt>
<dd>Initialize .xz Block encoder
<p></p>
Valid actions for lzma_code() are LZMA_RUN, LZMA_SYNC_FLUSH (only if the
 filter chain supports it), and LZMA_FINISH.

<p></p>
<b>Returns:</b><br>- LZMA_OK: All good, continue with lzma_code().
              - LZMA_MEM_ERROR
              - LZMA_OPTIONS_ERROR
              - LZMA_UNSUPPORTED_CHECK: <i>block</i>.check specifies a Check ID
                that is not supported by this buid of liblzma. Initializing
                the encoder failed.
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_block_decoder"></a><span class="ddoc_psymbol">lzma_block_decoder</span>(lzma_stream* <i>strm</i>, lzma_block* <i>block</i>);
</dt>
<dd>Initialize .xz Block decoder
<p></p>
Valid actions for lzma_code() are LZMA_RUN and LZMA_FINISH. Using
 LZMA_FINISH is not required. It is supported only for convenience.

<p></p>
<b>Returns:</b><br>- LZMA_OK: All good, continue with lzma_code().
              - LZMA_UNSUPPORTED_CHECK: Initialization was successful, but
                the given Check ID is not supported, thus Check will be
                ignored.
              - LZMA_PROG_ERROR
              - LZMA_MEM_ERROR<p></p>

</dd>
<dt class="d_decl">size_t <a name="lzma_block_buffer_bound"></a><span class="ddoc_psymbol">lzma_block_buffer_bound</span>(size_t <i>uncompressed_size</i>);
</dt>
<dd>Calculate maximum output size for single-call Block encoding
<p></p>
This is equivalent to lzma_stream_buffer_bound() but for .xz Blocks.
 See the documentation of lzma_stream_buffer_bound().<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_block_buffer_encode"></a><span class="ddoc_psymbol">lzma_block_buffer_encode</span>(lzma_block* <i>block</i>, lzma_allocator* <i>allocator</i>, const(ubyte)* <i>in_</i>, size_t <i>in_size</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Single-call .xz Block encoder
<p></p>
In contrast to the multi-call encoder initialized with
 lzma_block_encoder(), this function encodes also the Block Header. This
 is required to make it possible to write appropriate Block Header also
 in case the data isn't compressible, and different filter chain has to be
 used to encode the data in uncompressed form using uncompressed chunks
 of the LZMA2 filter.
<p></p>

 When the data isn't compressible, header_size, compressed_size, and
 uncompressed_size are set just like when the data was compressible, but
 it is possible that header_size is too small to hold the filter chain
 specified in <i>block</i>.filters, because that isn't necessarily the filter
 chain that was actually used to encode the data. lzma_block_unpadded_size()
 still works normally, because it doesn't read the filters array.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_block* <i>block</i></td>
<td valign=top>Block options: <i>block</i>.version_, <i>block</i>.check,
                          and <i>block</i>.filters must have been initialized.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>lzma_allocator for custom <i>allocator</i> functions.
                          Set to NULL to use malloc() and free().</td></tr>
<tr><td valign=top>const(ubyte)* <i>in_</i></td>
<td valign=top>Beginning of the input buffer</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>Size of the input buffer</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>The next byte will be written to out[*<i>out_pos</i>].
                          *<i>out_pos</i> is updated only if encoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>Size of the out buffer; the first byte into
                          which no data is written to is out[<i>out_size</i>].
<p></p>

 Returns      - LZMA_OK: Encoding was successful.
              - LZMA_BUF_ERROR: Not enough output buffer space.
              - LZMA_OPTIONS_ERROR
              - LZMA_MEM_ERROR
              - LZMA_DATA_ERROR
              - LZMA_PROG_ERROR</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_block_buffer_decode"></a><span class="ddoc_psymbol">lzma_block_buffer_decode</span>(lzma_block* <i>block</i>, lzma_allocator* <i>allocator</i>, const(ubyte)* <i>in_</i>, uint* <i>in_pos</i>, size_t <i>in_size</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Single-call .xz Block decoder
<p></p>
This is single-call equivalent of lzma_block_decoder(), and requires that
 the caller has already decoded Block Header and checked its memory usage.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_block* <i>block</i></td>
<td valign=top>Block options just like with lzma_block_decoder().</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>lzma_allocator for custom <i>allocator</i> functions.
                          Set to NULL to use malloc() and free().</td></tr>
<tr><td valign=top>const(ubyte)* <i>in_</i></td>
<td valign=top>Beginning of the input buffer</td></tr>
<tr><td valign=top>uint* <i>in_pos</i></td>
<td valign=top>The next byte will be read from in[*<i>in_pos</i>].
                          *<i>in_pos</i> is updated only if decoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>Size of the input buffer; the first byte that
                          won't be read is in[<i>in_size</i>].</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>The next byte will be written to out[*<i>out_pos</i>].
                          *<i>out_pos</i> is updated only if encoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>Size of the out buffer; the first byte into
                          which no data is written to is out[<i>out_size</i>].
<p></p>

 Returns      - LZMA_OK: Decoding was successful.
              - LZMA_OPTIONS_ERROR
              - LZMA_DATA_ERROR
              - LZMA_MEM_ERROR
              - LZMA_BUF_ERROR: Output buffer was too small.
              - LZMA_PROG_ERROR</td></tr>
</table><p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
