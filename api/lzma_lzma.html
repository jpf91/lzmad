<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.lzma - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.lzma</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/lzma.d -->
LZMA1 and LZMA2 filters
<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">ulong <a name="LZMA_FILTER_LZMA1"></a><span class="ddoc_psymbol">LZMA_FILTER_LZMA1</span>;
</dt>
<dd>LZMA1 Filter ID
<p></p>
LZMA1 is the very same thing as what was called just LZMA in LZMA Utils,
 7-Zip, and LZMA SDK. It's called LZMA1 here to prevent developers from
 accidentally using LZMA when they actually want LZMA2.
<p></p>

 LZMA1 shouldn't be used for new applications unless you really_ know
 what you are doing. LZMA2 is almost always a better choice.<p></p>

</dd>
<dt class="d_decl">ulong <a name="LZMA_FILTER_LZMA2"></a><span class="ddoc_psymbol">LZMA_FILTER_LZMA2</span>;
</dt>
<dd>LZMA2 Filter ID
<p></p>
Usually you want this instead of LZMA1. Compared to LZMA1, LZMA2 adds
 support for LZMA_SYNC_FLUSH, uncompressed chunks (smaller expansion
 when trying to compress uncompressible data), possibility to change
 lc/lp/pb in the middle of encoding, and some other internal improvements.<p></p>

</dd>
<dt class="d_decl">enum <a name="lzma_match_finder"></a><span class="ddoc_psymbol">lzma_match_finder</span>;
</dt>
<dd>Match finders
<p></p>
Match finder has major effect on both speed and compression ratio.
 Usually hash chains are faster than binary trees.
<p></p>

 If you will use LZMA_SYNC_FLUSH often, the hash chains may be a better
 choice, because binary trees get much higher compression ratio penalty
 with LZMA_SYNC_FLUSH.
<p></p>

 The memory usage formulas are only rough estimates, which are closest to
 reality when dict_size is a power of two. The formulas are  more complex
 in reality, and can also change a little between liblzma versions. Use
 lzma_raw_encoder_memusage() to get more accurate estimate of memory usage.<p></p>

<dl><dt class="d_decl"><a name="LZMA_MF_HC3"></a><span class="ddoc_psymbol">LZMA_MF_HC3</span></dt>
<dd>Hash Chain with 2- and 3-byte hashing
<p></p>
Minimum nice_len: 3
<p></p>

 Memory usage:
  - dict_size &lt;= 16 MiB: dict_size * 7.5
  - dict_size &gt; 16 MiB: dict_size * 5.5 + 64 MiB<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_MF_HC4"></a><span class="ddoc_psymbol">LZMA_MF_HC4</span></dt>
<dd>Hash Chain with 2-, 3-, and 4-byte hashing
<p></p>
Minimum nice_len: 4
<p></p>

 Memory usage:
  - dict_size &lt;= 32 MiB: dict_size * 7.5
  - dict_size &gt; 32 MiB: dict_size * 6.5<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_MF_BT2"></a><span class="ddoc_psymbol">LZMA_MF_BT2</span></dt>
<dd>Binary Tree with 2-byte hashing
<p></p>
Minimum nice_len: 2
<p></p>

 Memory usage: dict_size * 9.5<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_MF_BT3"></a><span class="ddoc_psymbol">LZMA_MF_BT3</span></dt>
<dd>Binary Tree with 2- and 3-byte hashing
<p></p>
Minimum nice_len: 3
<p></p>

 Memory usage:
  - dict_size &lt;= 16 MiB: dict_size * 11.5
  - dict_size &gt; 16 MiB: dict_size * 9.5 + 64 MiB<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_MF_BT4"></a><span class="ddoc_psymbol">LZMA_MF_BT4</span></dt>
<dd>Binary Tree with 2-, 3-, and 4-byte hashing
<p></p>
Minimum nice_len: 4
<p></p>

 Memory usage:
  - dict_size &lt;= 32 MiB: dict_size * 11.5
  - dict_size &gt; 32 MiB: dict_size * 10.5<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">lzma_bool <a name="lzma_mf_is_supported"></a><span class="ddoc_psymbol">lzma_mf_is_supported</span>(lzma_match_finder <i>match_finder</i>);
</dt>
<dd>Test if given match finder is supported
<p></p>
Return <b>true</b> if the given match finder is supported by this liblzma build.
 Otherwise <b>false</b> is returned. It is safe to call this with a value that
 isn't listed in lzma_match_finder enumeration; the return value will be
 <b>false</b>.
<p></p>

 There is no way to list which match finders are available in this
 particular liblzma version and build. It would be useless, because
 a new match finder, which the application developer wasn't aware,
 could require giving additional options to the encoder that the older
 match finders don't need.<p></p>

</dd>
<dt class="d_decl">enum <a name="lzma_mode"></a><span class="ddoc_psymbol">lzma_mode</span>;
</dt>
<dd>Compression modes
<p></p>
This selects the function used to analyze the data produced by the match
 finder.<p></p>

<dl><dt class="d_decl"><a name="LZMA_MODE_FAST"></a><span class="ddoc_psymbol">LZMA_MODE_FAST</span></dt>
<dd>Fast compression
<p></p>
Fast mode is usually at its best when combined with
 a hash chain match finder.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_MODE_NORMAL"></a><span class="ddoc_psymbol">LZMA_MODE_NORMAL</span></dt>
<dd>Normal compression
<p></p>
This is usually notably slower than fast mode. Use this
 together with binary tree match finders to expose the
 full potential of the LZMA1 or LZMA2 encoder.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">lzma_bool <a name="lzma_mode_is_supported"></a><span class="ddoc_psymbol">lzma_mode_is_supported</span>(lzma_mode <i>mode</i>);
</dt>
<dd>Test if given compression <i>mode</i> is supported
<p></p>
Return <b>true</b> if the given compression <i>mode</i> is supported by this liblzma
 build. Otherwise <b>false</b> is returned. It is safe to call this with a value
 that isn't listed in lzma_mode enumeration; the return value will be <b>false</b>.
<p></p>

 There is no way to list which modes are available in this particular
 liblzma version and build. It would be useless, because a new compression
 <i>mode</i>, which the application developer wasn't aware, could require giving
 additional options to the encoder that the older modes don't need.<p></p>

</dd>
<dt class="d_decl">struct <a name="lzma_options_lzma"></a><span class="ddoc_psymbol">lzma_options_lzma</span>;
</dt>
<dd>Options specific to the LZMA1 and LZMA2 filters
<p></p>
Since LZMA1 and LZMA2 share most of the code, it's simplest to share
 the options structure too. For encoding, all but the reserved variables
 need to be initialized unless specifically mentioned otherwise.
 lzma_lzma_preset() can be used to get a good starting point.
<p></p>

 For raw decoding, both LZMA1 and LZMA2 need dict_size, preset_dict, and
 preset_dict_size (if preset_dict != NULL). LZMA1 needs also lc, lp, and pb.<p></p>

<dl><dt class="d_decl">uint <a name="dict_size"></a><span class="ddoc_psymbol">dict_size</span>;
</dt>
<dd>Dictionary size in bytes
<p></p>
Dictionary size indicates how many bytes of the recently processed
 uncompressed data is kept in memory. One method to reduce size of
 the uncompressed data is to store distance-length pairs, which
 indicate what data to repeat from the dictionary buffer. Thus,
 the bigger the dictionary, the better the compression ratio
 usually is.
<p></p>

 Maximum size of the dictionary depends on multiple things:
  - Memory usage limit
  - Available address space (not a problem on 64-bit systems)
  - Selected match finder (encoder only)
<p></p>

 Currently the maximum dictionary size for encoding is 1.5 GiB
 (i.e. (UINT32_C(1) &lt;&lt; 30) + (UINT32_C(1) &lt;&lt; 29)) even on 64-bit
 systems for certain match finder implementation reasons. In the
 future, there may be match finders that support bigger
 dictionaries.
<p></p>

 Decoder already supports dictionaries up to 4 GiB - 1 B (i.e.
 UINT32_MAX), so increasing the maximum dictionary size of the
 encoder won't cause problems for old decoders.
<p></p>

 Because extremely small dictionaries sizes would have unneeded
 overhead in the decoder, the minimum dictionary size is 4096 bytes.

<p></p>
<b>Note:</b><br>
When decoding, too big dictionary does no other harm
              than wasting memory.<p></p>

</dd>
<dt class="d_decl">uint <a name="LZMA_DICT_SIZE_MIN"></a><span class="ddoc_psymbol">LZMA_DICT_SIZE_MIN</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">uint <a name="LZMA_DICT_SIZE_DEFAULT"></a><span class="ddoc_psymbol">LZMA_DICT_SIZE_DEFAULT</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">const ubyte* <a name="preset_dict"></a><span class="ddoc_psymbol">preset_dict</span>;
</dt>
<dd>Pointer to an initial dictionary
<p></p>
It is possible to initialize the LZ77 history window using
 a preset dictionary. It is useful when compressing many
 similar, relatively small chunks of data independently from
 each other. The preset dictionary should contain typical
 strings that occur in the files being compressed. The most
 probable strings should be near the end of the preset dictionary.
<p></p>

 This feature should be used only in special situations. For
 now, it works correctly only with raw encoding and decoding.
 Currently none of the container formats supported by
 liblzma allow preset dictionary when decoding, thus if
 you create a .xz or .lzma file with preset dictionary, it
 cannot be decoded with the regular decoder functions. In the
 future, the .xz format will likely get support for preset
 dictionary though.<p></p>

</dd>
<dt class="d_decl">uint <a name="preset_dict_size"></a><span class="ddoc_psymbol">preset_dict_size</span>;
</dt>
<dd>Size of the preset dictionary
<p></p>
Specifies the size of the preset dictionary. If the size is
 bigger than dict_size, only the last dict_size bytes are
 processed.
<p></p>

 This variable is read only when preset_dict is not NULL.
 If preset_dict is not NULL but <a name="preset_dict_size"></a><span class="ddoc_psymbol">preset_dict_size</span> is zero,
 no preset dictionary is used (identical to only setting
 preset_dict to NULL).<p></p>

</dd>
<dt class="d_decl">uint <a name="lc"></a><span class="ddoc_psymbol">lc</span>;
</dt>
<dd>Number of literal context bits
<p></p>
How many of the highest bits of the previous uncompressed
 eight-bit byte (also known as `literal') are taken into
 account when predicting the bits of the next literal.
<p></p>

 E.g. in typical English text, an upper-case letter is
 often followed by a lower-case letter, and a lower-case
 letter is usually followed by another lower-case letter.
 In the US-ASCII character set, the highest three bits are 010
 for upper-case letters and 011 for lower-case letters.
 When <a name="lc"></a><span class="ddoc_psymbol">lc</span> is at least 3, the literal coding can take advantage of
 this property in the uncompressed data.
<p></p>

 There is a limit that applies to literal context bits and literal
 position bits together: <a name="lc"></a><span class="ddoc_psymbol">lc</span> + lp &lt;= 4. Without this limit the
 decoding could become very slow, which could have security related
 results in some cases like email servers doing virus scanning.
 This limit also simplifies the internal implementation in liblzma.
<p></p>

 There may be LZMA1 streams that have <a name="lc"></a><span class="ddoc_psymbol">lc</span> + lp &gt; 4 (maximum possible
 <a name="lc"></a><span class="ddoc_psymbol">lc</span> would be 8). It is not possible to decode such streams with
 liblzma.<p></p>

</dd>
<dt class="d_decl">int <a name="LZMA_LCLP_MIN"></a><span class="ddoc_psymbol">LZMA_LCLP_MIN</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="LZMA_LCLP_MAX"></a><span class="ddoc_psymbol">LZMA_LCLP_MAX</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="LZMA_LC_DEFAULT"></a><span class="ddoc_psymbol">LZMA_LC_DEFAULT</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">uint <a name="lp"></a><span class="ddoc_psymbol">lp</span>;
</dt>
<dd>Number of literal position bits
<p></p>
<a name="lp"></a><span class="ddoc_psymbol">lp</span> affects what kind of alignment in the uncompressed data is
 assumed when encoding literals. A literal is a single 8-bit byte.
 See pb below for more information about alignment.<p></p>

</dd>
<dt class="d_decl">int <a name="LZMA_LP_DEFAULT"></a><span class="ddoc_psymbol">LZMA_LP_DEFAULT</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">uint <a name="pb"></a><span class="ddoc_psymbol">pb</span>;
</dt>
<dd>Number of position bits
<p></p>
<a name="pb"></a><span class="ddoc_psymbol">pb</span> affects what kind of alignment in the uncompressed data is
 assumed in general. The default means four-byte alignment
 (2^ <a name="pb"></a><span class="ddoc_psymbol">pb</span> =2^2=4), which is often a good choice when there's
 no better guess.
<p></p>

 When the aligment is known, setting <a name="pb"></a><span class="ddoc_psymbol">pb</span> accordingly may reduce
 the file size a little. E.g. with text files having one-byte
 alignment (US-ASCII, ISO-8859-*, UTF-8), setting <a name="pb"></a><span class="ddoc_psymbol">pb</span>=0 can
 improve compression slightly. For UTF-16 text, <a name="pb"></a><span class="ddoc_psymbol">pb</span>=1 is a good
 choice. If the alignment is an odd number like 3 bytes, <a name="pb"></a><span class="ddoc_psymbol">pb</span>=0
 might be the best choice.
<p></p>

 Even though the assumed alignment can be adjusted with <a name="pb"></a><span class="ddoc_psymbol">pb</span> and
 lp, LZMA1 and LZMA2 still slightly favor 16-byte alignment.
 It might be worth taking into account when designing file formats
 that are likely to be often compressed with LZMA1 or LZMA2.<p></p>

</dd>
<dt class="d_decl">int <a name="LZMA_PB_MIN"></a><span class="ddoc_psymbol">LZMA_PB_MIN</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="LZMA_PB_MAX"></a><span class="ddoc_psymbol">LZMA_PB_MAX</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">int <a name="LZMA_PB_DEFAULT"></a><span class="ddoc_psymbol">LZMA_PB_DEFAULT</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">lzma_mode <a name="mode"></a><span class="ddoc_psymbol">mode</span>;
</dt>
<dd>Compression <a name="mode"></a><span class="ddoc_psymbol">mode</span> <p></p>

</dd>
<dt class="d_decl">uint <a name="nice_len"></a><span class="ddoc_psymbol">nice_len</span>;
</dt>
<dd>Nice length of a match
<p></p>
This determines how many bytes the encoder compares from the match
 candidates when looking for the best match. Once a match of at
 least <a name="nice_len"></a><span class="ddoc_psymbol">nice_len</span> bytes long is found, the encoder stops looking for
 better candidates and encodes the match. (Naturally, if the found
 match is actually longer than <a name="nice_len"></a><span class="ddoc_psymbol">nice_len</span>, the actual length is
 encoded; it's not truncated to <a name="nice_len"></a><span class="ddoc_psymbol">nice_len</span>.)
<p></p>

 Bigger values usually increase the compression ratio and
 compression time. For most files, 32 to 128 is a good value,
 which gives very good compression ratio at good speed.
<p></p>

 The exact minimum value depends on the match finder. The maximum
 is 273, which is the maximum length of a match that LZMA1 and
 LZMA2 can encode.<p></p>

</dd>
<dt class="d_decl">lzma_match_finder <a name="mf"></a><span class="ddoc_psymbol">mf</span>;
</dt>
<dd>Match finder ID <p></p>

</dd>
<dt class="d_decl">uint <a name="depth"></a><span class="ddoc_psymbol">depth</span>;
</dt>
<dd>Maximum search <a name="depth"></a><span class="ddoc_psymbol">depth</span> in the match finder
<p></p>
For every input byte, match finder searches through the hash chain
 or binary tree in a loop, each iteration going one step deeper in
 the chain or tree. The searching stops if
  - a match of at least nice_len bytes long is found;
  - all match candidates from the hash chain or binary tree have
    been checked; or
  - maximum search <a name="depth"></a><span class="ddoc_psymbol">depth</span> is reached.
<p></p>

 Maximum search <a name="depth"></a><span class="ddoc_psymbol">depth</span> is needed to prevent the match finder from
 wasting too much time in case there are lots of short match
 candidates. On the other hand, stopping the search before all
 candidates have been checked can reduce compression ratio.
<p></p>

 Setting <a name="depth"></a><span class="ddoc_psymbol">depth</span> to zero tells liblzma to use an automatic default
 value, that depends on the selected match finder and nice_len.
 The default is in the range [4, 200] or so (it may vary between
 liblzma versions).
<p></p>

 Using a bigger <a name="depth"></a><span class="ddoc_psymbol">depth</span> value than the default can increase
 compression ratio in some cases. There is no strict maximum value,
 but high values (thousands or millions) should be used with care:
 the encoder could remain fast enough with typical input, but
 malicious input could cause the match finder to slow down
 dramatically, possibly creating a denial of service attack.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">lzma_bool <a name="lzma_lzma_preset"></a><span class="ddoc_psymbol">lzma_lzma_preset</span>(lzma_options_lzma* <i>options</i>, uint <i>preset</i>);
</dt>
<dd>Set a compression <i>preset</i> to lzma_options_lzma structure
<p></p>
0 is the fastest and 9 is the slowest. These match the switches -0 .. -9
 of the xz command line tool. In addition, it is possible to bitwise-or
 flags to the <i>preset</i>. Currently only LZMA_PRESET_EXTREME is supported.
 The flags are defined in container.h, because the flags are used also
 with lzma_easy_encoder().
<p></p>

 The <i>preset</i> values are subject to changes between liblzma versions.
<p></p>

 This function is available only if LZMA1 or LZMA2 encoder has been enabled
 when building liblzma.<p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
