<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.filter - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.filter</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/filter.d -->
Common <a name="filter"></a><span class="ddoc_psymbol">filter</span> related types and functions
<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">int <a name="LZMA_FILTERS_MAX"></a><span class="ddoc_psymbol">LZMA_FILTERS_MAX</span>;
</dt>
<dd>Maximum number of filters in a chain
<p></p>
A filter chain can have 1-4 filters, of which three are allowed to change
 the size of the data. Usually only one or two filters are needed.<p></p>

</dd>
<dt class="d_decl">struct <a name="lzma_filter"></a><span class="ddoc_psymbol">lzma_filter</span>;
</dt>
<dd>Filter options
<p></p>
This structure is used to pass Filter ID and a pointer filter's
 options to liblzma. A few functions work with a single <a name="lzma_filter"></a><span class="ddoc_psymbol">lzma_filter</span>
 structure, while most functions expect a filter chain.
<p></p>

 A filter chain is indicated with an array of <a name="lzma_filter"></a><span class="ddoc_psymbol">lzma_filter</span> structures.
 The array is terminated with .id = LZMA_VLI_UNKNOWN. Thus, the filter
 array must have LZMA_FILTERS_MAX + 1 elements (that is, five) to
 be able to hold any arbitrary filter chain. This is important when
 using lzma_block_header_decode() from block.h, because too small
 array would make liblzma write past the end of the filters array.<p></p>

<dl><dt class="d_decl">lzma_vli <a name="id"></a><span class="ddoc_psymbol">id</span>;
</dt>
<dd>Filter ID
<p></p>
Use constants whose name begin with `LZMA_FILTER_' to specify
 different filters. In an array of lzma_filter structures, use
 LZMA_VLI_UNKNOWN to indicate end of filters.

<p></p>
<b>Note:</b><br>
This is not an enum, because on some systems enums
              cannot be 64-bit.<p></p>

</dd>
<dt class="d_decl">void* <a name="options"></a><span class="ddoc_psymbol">options</span>;
</dt>
<dd>Pointer to filter-specific <a name="options"></a><span class="ddoc_psymbol">options</span> structure
<p></p>
If the filter doesn't need <a name="options"></a><span class="ddoc_psymbol">options</span>, set this to NULL. If id is
 set to LZMA_VLI_UNKNOWN, <a name="options"></a><span class="ddoc_psymbol">options</span> is ignored, and thus
 doesn't need be initialized.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">lzma_bool <a name="lzma_filter_encoder_is_supported"></a><span class="ddoc_psymbol">lzma_filter_encoder_is_supported</span>(lzma_vli <i>id</i>);
</dt>
<dd>Test if the given Filter ID is supported for encoding
<p></p>
Return <b>true</b> if the give Filter ID is supported for encoding by this
 liblzma build. Otherwise <b>false</b> is returned.
<p></p>

 There is no way to list which filters are available in this particular
 liblzma version and build. It would be useless, because the application
 couldn't know what kind of options the filter would need.<p></p>

</dd>
<dt class="d_decl">lzma_bool <a name="lzma_filter_decoder_is_supported"></a><span class="ddoc_psymbol">lzma_filter_decoder_is_supported</span>(lzma_vli <i>id</i>);
</dt>
<dd>Test if the given Filter ID is supported for decoding
<p></p>
Return <b>true</b> if the give Filter ID is supported for decoding by this
 liblzma build. Otherwise <b>false</b> is returned.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_filters_copy"></a><span class="ddoc_psymbol">lzma_filters_copy</span>(const lzma_filter* <i>src</i>, lzma_filter* <i>dest</i>, lzma_allocator* <i>allocator</i>);
</dt>
<dd>Copy the filters array
<p></p>
Copy the Filter IDs and filter-specific options from <i>src</i> to <i>dest</i>.
 Up to LZMA_FILTERS_MAX filters are copied, plus the terminating
 .id == LZMA_VLI_UNKNOWN. Thus, <i>dest</i> should have at least
 LZMA_FILTERS_MAX + 1 elements space unless the caller knows that
 <i>src</i> is smaller than that.
<p></p>

 Unless the filter-specific options is NULL, the Filter ID has to be
 supported by liblzma, because liblzma needs to know the size of every
 filter-specific options structure. The filter-specific options are not
 validated. If options is NULL, any unsupported Filter IDs are copied
 without returning an error.
<p></p>

 Old filter-specific options in <i>dest</i> are not freed, so <i>dest</i> doesn't
 need to be initialized by the caller in any way.
<p></p>

 If an error occurs, memory possibly already allocated by this function
 is always freed.

<p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_MEM_ERROR
              - LZMA_OPTIONS_ERROR: Unsupported Filter ID and its options
                is not NULL.
              - LZMA_PROG_ERROR: <i>src</i> or <i>dest</i> is NULL.<p></p>

</dd>
<dt class="d_decl">ulong <a name="lzma_raw_encoder_memusage"></a><span class="ddoc_psymbol">lzma_raw_encoder_memusage</span>(const lzma_filter* <i>filters</i>);
</dt>
<dd>Calculate approximate memory requirements for raw encoder
<p></p>
This function can be used to calculate the memory requirements for
 Block and Stream encoders too because Block and Stream encoders don't
 need significantly more memory than raw encoder.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_filter* <i>filters</i></td>
<td valign=top>Array of <i>filters</i> terminated with
                          .id == LZMA_VLI_UNKNOWN.</td></tr>
</table><p></p>
<b>Returns:</b><br>Number of bytes of memory required for the given
              filter chain when encoding.<p></p>

</dd>
<dt class="d_decl">ulong <a name="lzma_raw_decoder_memusage"></a><span class="ddoc_psymbol">lzma_raw_decoder_memusage</span>(const lzma_filter* <i>filters</i>);
</dt>
<dd>Calculate approximate memory requirements for raw decoder
<p></p>
This function can be used to calculate the memory requirements for
 Block and Stream decoders too because Block and Stream decoders don't
 need significantly more memory than raw decoder.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_filter* <i>filters</i></td>
<td valign=top>Array of <i>filters</i> terminated with
                          .id == LZMA_VLI_UNKNOWN.</td></tr>
</table><p></p>
<b>Returns:</b><br>Number of bytes of memory required for the given
              filter chain when decoding.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_raw_encoder"></a><span class="ddoc_psymbol">lzma_raw_encoder</span>(lzma_stream* <i>strm</i>, const lzma_filter* <i>filters</i>);
</dt>
<dd>Initialize raw encoder
<p></p>
This function may be useful when implementing custom file formats.

<p></p>
<b>Parameters:</b><table class=parms></table><p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_MEM_ERROR
              - LZMA_OPTIONS_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_raw_decoder"></a><span class="ddoc_psymbol">lzma_raw_decoder</span>(lzma_stream* <i>strm</i>, const lzma_filter* <i>filters</i>);
</dt>
<dd>Initialize raw decoder
<p></p>
The initialization of raw decoder goes similarly to raw encoder.
<p></p>

 The `action' with lzma_code() can be LZMA_RUN or LZMA_FINISH. Using
 LZMA_FINISH is not required, it is supported just for convenience.

<p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_MEM_ERROR
              - LZMA_OPTIONS_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_filters_update"></a><span class="ddoc_psymbol">lzma_filters_update</span>(lzma_stream* <i>strm</i>, const lzma_filter* <i>filters</i>);
</dt>
<dd>Update the filter chain in the encoder
<p></p>
This function is for advanced users only. This function has two slightly
 different purposes:
<p></p>

  - After LZMA_FULL_FLUSH when using Stream encoder: Set a new filter
    chain, which will be used starting from the next Block.
<p></p>

  - After LZMA_SYNC_FLUSH using Raw, Block, or Stream encoder: Change
    the filter-specific options in the middle of encoding. The actual
    <i>filters</i> in the chain (Filter IDs) cannot be changed. In the future,
    it might become possible to change the filter options without
    using LZMA_SYNC_FLUSH.
<p></p>

 While rarely useful, this function may be called also when no data has
 been compressed yet. In that case, this function will behave as if
 LZMA_FULL_FLUSH (Stream encoder) or LZMA_SYNC_FLUSH (Raw or Block
 encoder) had been used right before calling this function.

<p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_MEM_ERROR
              - LZMA_MEMLIMIT_ERROR
              - LZMA_OPTIONS_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_raw_buffer_encode"></a><span class="ddoc_psymbol">lzma_raw_buffer_encode</span>(const lzma_filter* <i>filters</i>, lzma_allocator* <i>allocator</i>, const(ubyte)* <i>in_</i>, size_t <i>in_size</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Single-call raw encoder
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_filter* <i>filters</i></td>
<td valign=top>Array of lzma_filter structures. The end of the
                          array must be marked with .id = LZMA_VLI_UNKNOWN.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>lzma_allocator for custom <i>allocator</i> functions.
                          Set to NULL to use malloc() and free().</td></tr>
<tr><td valign=top>const(ubyte)* <i>in_</i></td>
<td valign=top>Beginning of the input buffer</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>Size of the input buffer</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>The next byte will be written to out[*<i>out_pos</i>].
                          *<i>out_pos</i> is updated only if encoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>Size of the out buffer; the first byte into
                          which no data is written to is out[<i>out_size</i>].</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Encoding was successful.
              - LZMA_BUF_ERROR: Not enough output buffer space.
              - LZMA_OPTIONS_ERROR
              - LZMA_MEM_ERROR
              - LZMA_DATA_ERROR
              - LZMA_PROG_ERROR

<p></p>
<b>Note:</b><br>
There is no function to calculate how big output buffer
              would surely be big enough. (lzma_stream_buffer_bound()
              works only for lzma_stream_buffer_encode(); raw encoder
              won't necessarily meet that bound.)<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_raw_buffer_decode"></a><span class="ddoc_psymbol">lzma_raw_buffer_decode</span>(const lzma_filter* <i>filters</i>, lzma_allocator* <i>allocator</i>, const(ubyte)* <i>in_</i>, uint* <i>in_pos</i>, size_t <i>in_size</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Single-call raw decoder
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_filter* <i>filters</i></td>
<td valign=top>Array of lzma_filter structures. The end of the
                          array must be marked with .id = LZMA_VLI_UNKNOWN.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>lzma_allocator for custom <i>allocator</i> functions.
                          Set to NULL to use malloc() and free().</td></tr>
<tr><td valign=top>const(ubyte)* <i>in_</i></td>
<td valign=top>Beginning of the input buffer</td></tr>
<tr><td valign=top>uint* <i>in_pos</i></td>
<td valign=top>The next byte will be read from in[*<i>in_pos</i>].
                          *<i>in_pos</i> is updated only if decoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>Size of the input buffer; the first byte that
                          won't be read is in[<i>in_size</i>].</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>The next byte will be written to out[*<i>out_pos</i>].
                          *<i>out_pos</i> is updated only if encoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>Size of the out buffer; the first byte into
                          which no data is written to is out[<i>out_size</i>].</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_properties_size"></a><span class="ddoc_psymbol">lzma_properties_size</span>(uint* <i>size</i>, const lzma_filter* <i>filter</i>);
</dt>
<dd>Get the <i>size</i> of the Filter Properties field
<p></p>
This function may be useful when implementing custom file formats
 using the raw encoder and decoder.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>uint* <i>size</i></td>
<td valign=top>Pointer to uint to hold the <i>size</i> of the properties</td></tr>
<tr><td valign=top>lzma_filter* <i>filter</i></td>
<td valign=top>Filter ID and options (the <i>size</i> of the properties may
                      vary depending on the options)</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_OPTIONS_ERROR
              - LZMA_PROG_ERROR

<p></p>
<b>Note:</b><br>
This function validates the Filter ID, but does not
              necessarily validate the options. Thus, it is possible
              that this returns LZMA_OK while the following call to
              lzma_properties_encode() returns LZMA_OPTIONS_ERROR.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_properties_encode"></a><span class="ddoc_psymbol">lzma_properties_encode</span>(const lzma_filter* <i>filter</i>, ubyte* <i>props</i>);
</dt>
<dd>Encode the Filter Properties field
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_filter* <i>filter</i></td>
<td valign=top>Filter ID and options</td></tr>
<tr><td valign=top>ubyte* <i>props</i></td>
<td valign=top>Buffer to hold the encoded options. The size of
                      buffer must have been already determined with
                      lzma_properties_size().</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_OPTIONS_ERROR
              - LZMA_PROG_ERROR

<p></p>
<b>Note:</b><br>
Even this function won't validate more options than actually
              necessary. Thus, it is possible that encoding the properties
              succeeds but using the same options to initialize the encoder
              will fail.

<p></p>
<b>Note:</b><br>
If lzma_properties_size() indicated that the size
              of the Filter Properties field is zero, calling
              <a name="lzma_properties_encode"></a><span class="ddoc_psymbol">lzma_properties_encode</span>() is not required, but it
              won't do any harm either.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_properties_decode"></a><span class="ddoc_psymbol">lzma_properties_decode</span>(lzma_filter* <i>filter</i>, lzma_allocator* <i>allocator</i>, const ubyte* <i>props</i>, size_t <i>props_size</i>);
</dt>
<dd>Decode the Filter Properties field
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_filter* <i>filter</i></td>
<td valign=top><i>filter</i>-&gt;id must have been set to the correct
                          Filter ID. <i>filter</i>-&gt;options doesn't need to be
                          initialized (it's not freed by this function). The
                          decoded options will be stored to <i>filter</i>-&gt;options.
                          <i>filter</i>-&gt;options is set to NULL if there are no
                          properties or if an error occurs.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>Custom memory <i>allocator</i> used to allocate the
                          options. Set to NULL to use the default malloc(),
                          and in case of an error, also free().</td></tr>
<tr><td valign=top>ubyte* <i>props</i></td>
<td valign=top>Input buffer containing the properties.</td></tr>
<tr><td valign=top>size_t <i>props_size</i></td>
<td valign=top>Size of the properties. This must be the exact
                          size; giving too much or too little input will
                          return LZMA_OPTIONS_ERROR.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_OPTIONS_ERROR
              - LZMA_MEM_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_filter_flags_size"></a><span class="ddoc_psymbol">lzma_filter_flags_size</span>(uint* <i>size</i>, const lzma_filter* <i>filter</i>);
</dt>
<dd>Calculate encoded <i>size</i> of a Filter Flags field
<p></p>
Knowing the <i>size</i> of Filter Flags is useful to know when allocating
 memory to hold the encoded Filter Flags.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>uint* <i>size</i></td>
<td valign=top>Pointer to integer to hold the calculated <i>size</i></td></tr>
<tr><td valign=top>lzma_filter* <i>filter</i></td>
<td valign=top>Filter ID and associated options whose encoded
                      <i>size</i> is to be calculated</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: *<i>size</i> set successfully. Note that this doesn't
                guarantee that <i>filter</i>-&gt;options is valid, thus
                lzma_filter_flags_encode() may still fail.
              - LZMA_OPTIONS_ERROR: Unknown Filter ID or unsupported options.
              - LZMA_PROG_ERROR: Invalid options

<p></p>
<b>Note:</b><br>
If you need to calculate <i>size</i> of List of Filter Flags,
              you need to loop over every lzma_filter entry.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_filter_flags_encode"></a><span class="ddoc_psymbol">lzma_filter_flags_encode</span>(const lzma_filter* <i>filter</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Encode Filter Flags into given buffer
<p></p>
In contrast to some functions, this doesn't allocate the needed buffer.
 This is due to how this function is used internally by liblzma.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_filter* <i>filter</i></td>
<td valign=top>Filter ID and options to be encoded</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>out[*<i>out_pos</i>] is the next write position. This
                       =   is updated by the encoder.</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>out[<i>out_size</i>] is the first byte to not write.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Encoding was successful.
              - LZMA_OPTIONS_ERROR: Invalid or unsupported options.
              - LZMA_PROG_ERROR: Invalid options or not enough output
                buffer space (you should have checked it with
                lzma_filter_flags_size()).<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_filter_flags_decode"></a><span class="ddoc_psymbol">lzma_filter_flags_decode</span>(lzma_filter* <i>filter</i>, lzma_allocator* <i>allocator</i>, const ubyte* <i>in_</i>, uint* <i>in_pos</i>, size_t <i>in_size</i>);
</dt>
<dd>Decode Filter Flags from given buffer
<p></p>
The decoded result is stored into *<i>filter</i>. The old value of
 <i>filter</i>-&gt;options is not free()d.

<p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_OPTIONS_ERROR
              - LZMA_MEM_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
