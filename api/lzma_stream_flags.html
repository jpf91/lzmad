<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.stream_flags - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.stream_flags</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/stream_flags.d -->
.xz Stream Header and Stream Footer encoder and decoder
<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">int <a name="LZMA_STREAM_HEADER_SIZE"></a><span class="ddoc_psymbol">LZMA_STREAM_HEADER_SIZE</span>;
</dt>
<dd>Size of Stream Header and Stream Footer
<p></p>
Stream Header and Stream Footer have the same size and they are not
 going to change even if a newer version of the .xz file format is
 developed in future.<p></p>

</dd>
<dt class="d_decl">struct <a name="lzma_stream_flags"></a><span class="ddoc_psymbol">lzma_stream_flags</span>;
</dt>
<dd>Options for encoding/decoding Stream Header and Stream Footer<p></p>

<dl><dt class="d_decl">uint <a name="version_"></a><span class="ddoc_psymbol">version_</span>;
</dt>
<dd>Stream Flags format version
<p></p>
To prevent API and ABI breakages if new features are needed in
 Stream Header or Stream Footer, a version number is used to
 indicate which fields in this structure are in use. For now,
 version must always be zero. With non-zero version, the
 lzma_stream_header_encode() and lzma_stream_footer_encode()
 will return LZMA_OPTIONS_ERROR.
<p></p>

 lzma_stream_header_decode() and lzma_stream_footer_decode()
 will always set this to the lowest value that supports all the
 features indicated by the Stream Flags field. The application
 must check that the version number set by the decoding functions
 is supported by the application. Otherwise it is possible that
 the application will decode the Stream incorrectly.<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="backward_size"></a><span class="ddoc_psymbol">backward_size</span>;
</dt>
<dd>Backward Size
<p></p>
Backward Size must be a multiple of four bytes. In this Stream
 format version, Backward Size is the size of the Index field.
<p></p>

 Backward Size isn't actually part of the Stream Flags field, but
 it is convenient to include in this structure anyway. Backward
 Size is present only in the Stream Footer. There is no need to
 initialize <a name="backward_size"></a><span class="ddoc_psymbol">backward_size</span> when encoding Stream Header.
<p></p>

 lzma_stream_header_decode() always sets <a name="backward_size"></a><span class="ddoc_psymbol">backward_size</span> to
 LZMA_VLI_UNKNOWN so that it is convenient to use
 lzma_stream_flags_compare() when both Stream Header and Stream
 Footer have been decoded.<p></p>

</dd>
<dt class="d_decl">int <a name="LZMA_BACKWARD_SIZE_MIN"></a><span class="ddoc_psymbol">LZMA_BACKWARD_SIZE_MIN</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">ulong <a name="LZMA_BACKWARD_SIZE_MAX"></a><span class="ddoc_psymbol">LZMA_BACKWARD_SIZE_MAX</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">lzma_check <a name="check"></a><span class="ddoc_psymbol">check</span>;
</dt>
<dd>Check ID
<p></p>
This indicates the type of the integrity <a name="check"></a><span class="ddoc_psymbol">check</span> calculated from
 uncompressed data.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">lzma_ret <a name="lzma_stream_header_encode"></a><span class="ddoc_psymbol">lzma_stream_header_encode</span>(const lzma_stream_flags* <i>options</i>, ubyte* <i>out_</i>);
</dt>
<dd>Encode Stream Header
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream_flags* <i>options</i></td>
<td valign=top>Stream Header <i>options</i> to be encoded.
                          <i>options</i>-&gt;backward_size is ignored and doesn't
                          need to be initialized.</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer of
                          LZMA_STREAM_HEADER_SIZE bytes.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Encoding was successful.
              - LZMA_OPTIONS_ERROR: <i>options</i>-&gt;version is not supported by
                this liblzma version.
              - LZMA_PROG_ERROR: Invalid <i>options</i>.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_stream_footer_encode"></a><span class="ddoc_psymbol">lzma_stream_footer_encode</span>(const lzma_stream_flags* <i>options</i>, ubyte* <i>out_</i>);
</dt>
<dd>Encode Stream Footer
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream_flags* <i>options</i></td>
<td valign=top>Stream Footer <i>options</i> to be encoded.</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer of
                          LZMA_STREAM_HEADER_SIZE bytes.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Encoding was successful.
              - LZMA_OPTIONS_ERROR: <i>options</i>-&gt;version is not supported by
                this liblzma version.
              - LZMA_PROG_ERROR: Invalid <i>options</i>.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_stream_header_decode"></a><span class="ddoc_psymbol">lzma_stream_header_decode</span>(lzma_stream_flags* <i>options</i>, const ubyte* <i>in_</i>);
</dt>
<dd>Decode Stream Header
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream_flags* <i>options</i></td>
<td valign=top>Target for the decoded Stream Header <i>options</i>.</td></tr>
<tr><td valign=top>ubyte* <i>in_</i></td>
<td valign=top>Beginning of the input buffer of
                          LZMA_STREAM_HEADER_SIZE bytes.
<p></p>

 <i>options</i>-&gt;backward_size is always set to LZMA_VLI_UNKNOWN. This is to
 help comparing Stream Flags from Stream Header and Stream Footer with
 lzma_stream_flags_compare().</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Decoding was successful.
              - LZMA_FORMAT_ERROR: Magic bytes don't match, thus the given
                buffer cannot be Stream Header.
              - LZMA_DATA_ERROR: CRC32 doesn't match, thus the header
                is corrupt.
              - LZMA_OPTIONS_ERROR: Unsupported <i>options</i> are present
                in the header.

<p></p>
<b>Note:</b><br>
When decoding .xz files that contain multiple Streams, it may
              make sense to print "file format not recognized" only if
              decoding of the Stream Header of the first_ Stream gives
              LZMA_FORMAT_ERROR. If non-first Stream Header gives
              LZMA_FORMAT_ERROR, the message used for LZMA_DATA_ERROR is
              probably more appropriate.
<p></p>

              For example, Stream decoder in liblzma uses LZMA_DATA_ERROR if
              LZMA_FORMAT_ERROR is returned by <a name="lzma_stream_header_decode"></a><span class="ddoc_psymbol">lzma_stream_header_decode</span>()
              when decoding non-first Stream.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_stream_footer_decode"></a><span class="ddoc_psymbol">lzma_stream_footer_decode</span>(lzma_stream_flags* <i>options</i>, const ubyte* <i>in_</i>);
</dt>
<dd>Decode Stream Footer
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream_flags* <i>options</i></td>
<td valign=top>Target for the decoded Stream Header <i>options</i>.</td></tr>
<tr><td valign=top>ubyte* <i>in_</i></td>
<td valign=top>Beginning of the input buffer of
                          LZMA_STREAM_HEADER_SIZE bytes.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Decoding was successful.
              - LZMA_FORMAT_ERROR: Magic bytes don't match, thus the given
                buffer cannot be Stream Footer.
              - LZMA_DATA_ERROR: CRC32 doesn't match, thus the Stream Footer
                is corrupt.
              - LZMA_OPTIONS_ERROR: Unsupported <i>options</i> are present
                in Stream Footer.

<p></p>
<b>Note:</b><br>
If Stream Header was already decoded successfully, but
              decoding Stream Footer returns LZMA_FORMAT_ERROR, the
              application should probably report some other error message
              than "file format not recognized", since the file more likely
              is corrupt (possibly truncated). Stream decoder in liblzma
              uses LZMA_DATA_ERROR in this situation.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_stream_flags_compare"></a><span class="ddoc_psymbol">lzma_stream_flags_compare</span>(const lzma_stream_flags* <i>a</i>, const lzma_stream_flags* <i>b</i>);
</dt>
<dd>Compare two lzma_stream_flags structures
<p></p>
backward_size values are compared only if both are not
 LZMA_VLI_UNKNOWN.

<p></p>
<b>Returns:</b><br>- LZMA_OK: Both are equal. If either had backward_size set
                to LZMA_VLI_UNKNOWN, backward_size values were not
                compared or validated.
              - LZMA_DATA_ERROR: The structures differ.
              - LZMA_OPTIONS_ERROR: version in either structure is greater
                than the maximum supported version (currently zero).
              - LZMA_PROG_ERROR: Invalid value, e.g. invalid check or
                backward_size.<p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
