<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.index - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.index</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/index.d -->
Handling of .xz Index and related information
<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">struct <a name="lzma_index"></a><span class="ddoc_psymbol">lzma_index</span>;
</dt>
<dd>Opaque data type to hold the Index(es) and other information
<p></p>
<a name="lzma_index"></a><span class="ddoc_psymbol">lzma_index</span> often holds just one .xz Index and possibly the Stream Flags
 of the same Stream and size of the Stream Padding field. However,
 multiple lzma_indexes can be concatenated with lzma_index_cat() and then
 there may be information about multiple Streams in the same <a name="lzma_index"></a><span class="ddoc_psymbol">lzma_index</span>.
<p></p>

 Notes about thread safety: Only one thread may modify <a name="lzma_index"></a><span class="ddoc_psymbol">lzma_index</span> at
 a time. All functions that take non-const pointer to <a name="lzma_index"></a><span class="ddoc_psymbol">lzma_index</span>
 modify it. As long as no thread is modifying the <a name="lzma_index"></a><span class="ddoc_psymbol">lzma_index</span>, getting
 information from the same <a name="lzma_index"></a><span class="ddoc_psymbol">lzma_index</span> can be done from multiple threads
 at the same time with functions that take a const pointer to
 <a name="lzma_index"></a><span class="ddoc_psymbol">lzma_index</span> or use lzma_index_iter. The same iterator must be used
 only by one thread at a time, of course, but there can be as many
 iterators for the same <a name="lzma_index"></a><span class="ddoc_psymbol">lzma_index</span> as needed.<p></p>

</dd>
<dt class="d_decl">struct <a name="lzma_index_iter"></a><span class="ddoc_psymbol">lzma_index_iter</span>;
</dt>
<dd>Iterator to get information about Blocks and Streams<p></p>

<dl><dt class="d_decl">StreamStruct <a name="stream"></a><span class="ddoc_psymbol">stream</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl">BlockStruct <a name="block"></a><span class="ddoc_psymbol">block</span>;
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="lzma_index_iter_mode"></a><span class="ddoc_psymbol">lzma_index_iter_mode</span>;
</dt>
<dd>Operation mode for lzma_index_iter_next()<p></p>

<dl><dt class="d_decl"><a name="LZMA_INDEX_ITER_ANY"></a><span class="ddoc_psymbol">LZMA_INDEX_ITER_ANY</span></dt>
<dd>Get the next Block or Stream
<p></p>
Go to the next Block if the current Stream has at least
 one Block left. Otherwise go to the next Stream even if
 it has no Blocks. If the Stream has no Blocks
 (lzma_index_iter.stream.block_count == 0),
 lzma_index_iter.block will have undefined values.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_INDEX_ITER_STREAM"></a><span class="ddoc_psymbol">LZMA_INDEX_ITER_STREAM</span></dt>
<dd>Get the next Stream
<p></p>
Go to the next Stream even if the current Stream has
 unread Blocks left. If the next Stream has at least one
 Block, the iterator will point to the first Block.
 If there are no Blocks, lzma_index_iter.block will have
 undefined values.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_INDEX_ITER_BLOCK"></a><span class="ddoc_psymbol">LZMA_INDEX_ITER_BLOCK</span></dt>
<dd>Get the next Block
<p></p>
Go to the next Block if the current Stream has at least
 one Block left. If the current Stream has no Blocks left,
 the next Stream with at least one Block is located and
 the iterator will be made to point to the first Block of
 that Stream.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_INDEX_ITER_NONEMPTY_BLOCK"></a><span class="ddoc_psymbol">LZMA_INDEX_ITER_NONEMPTY_BLOCK</span></dt>
<dd>Get the next non-empty Block
<p></p>
This is like LZMA_INDEX_ITER_BLOCK except that it will
 skip Blocks whose Uncompressed Size is zero.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">ulong <a name="lzma_index_memusage"></a><span class="ddoc_psymbol">lzma_index_memusage</span>(lzma_vli <i>streams</i>, lzma_vli <i>blocks</i>);
</dt>
<dd>Calculate memory usage of lzma_index
<p></p>
On disk, the size of the Index field depends on both the number of Records
 stored and how big values the Records store (due to variable-length integer
 encoding). When the Index is kept in lzma_index structure, the memory usage
 depends only on the number of Records/Blocks stored in the Index(es), and
 in case of concatenated lzma_indexes, the number of Streams. The size in
 RAM is almost always significantly bigger than in the encoded form on disk.
<p></p>

 This function calculates an approximate amount of memory needed hold
 the given number of Streams and Blocks in lzma_index structure. This
 value may vary between CPU architectures and also between liblzma versions
 if the internal implementation is modified.<p></p>

</dd>
<dt class="d_decl">ulong <a name="lzma_index_memused"></a><span class="ddoc_psymbol">lzma_index_memused</span>(const lzma_index* <i>i</i>);
</dt>
<dd>Calculate the memory usage of an existing lzma_index
<p></p>
This is a shorthand for lzma_index_memusage(lzma_index_stream_count(<i>i</i>),
 lzma_index_block_count(<i>i</i>)).<p></p>

</dd>
<dt class="d_decl">lzma_index* <a name="lzma_index_init"></a><span class="ddoc_psymbol">lzma_index_init</span>(lzma_allocator* <i>allocator</i>);
</dt>
<dd>Allocate and initialize a new lzma_index structure
<p></p>
<b>Returns:</b><br>On success, a pointer to an empty initialized lzma_index is
              returned. If allocation fails, NULL is returned.<p></p>

</dd>
<dt class="d_decl">void <a name="lzma_index_end"></a><span class="ddoc_psymbol">lzma_index_end</span>(lzma_index* <i>i</i>, lzma_allocator* <i>allocator</i>);
</dt>
<dd>Deallocate lzma_index
<p></p>
If <i>i</i> is NULL, this does nothing.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_append"></a><span class="ddoc_psymbol">lzma_index_append</span>(lzma_index* <i>i</i>, lzma_allocator* <i>allocator</i>, lzma_vli <i>unpadded_size</i>, lzma_vli <i>uncompressed_size</i>);
</dt>
<dd>Add a new Block to lzma_index
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_index* <i>i</i></td>
<td valign=top>Pointer to a lzma_index structure</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>Pointer to lzma_allocator, or NULL to
                                use malloc()</td></tr>
<tr><td valign=top>lzma_vli <i>unpadded_size</i></td>
<td valign=top>Unpadded Size of a Block. This can be
                                calculated with lzma_block_unpadded_size()
                                after encoding or decoding the Block.</td></tr>
<tr><td valign=top>lzma_vli <i>uncompressed_size</i></td>
<td valign=top>Uncompressed Size of a Block. This can be
                                taken directly from lzma_block structure
                                after encoding or decoding the Block.
<p></p>

 Appending a new Block does not invalidate iterators. For example,
 if an iterator was pointing to the end of the lzma_index, after
 <a name="lzma_index_append"></a><span class="ddoc_psymbol">lzma_index_append</span>() it is possible to read the next Block with
 an existing iterator.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_MEM_ERROR
              - LZMA_DATA_ERROR: Compressed or uncompressed size of the
                Stream or size of the Index field would grow too big.
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_stream_flags"></a><span class="ddoc_psymbol">lzma_index_stream_flags</span>(lzma_index* <i>i</i>, const lzma_stream_flags* <i>stream_flags</i>);
</dt>
<dd>Set the Stream Flags
<p></p>
Set the Stream Flags of the last (and typically the only) Stream
 in lzma_index. This can be useful when reading information from the
 lzma_index, because to decode Blocks, knowing the integrity check type
 is needed.
<p></p>

 The given Stream Flags are copied into internal preallocated structure
 in the lzma_index, thus the caller doesn't need to keep the *<i>stream_flags</i>
 available after calling this function.

<p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_OPTIONS_ERROR: Unsupported <i>stream_flags</i>-&gt;version.
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">uint <a name="lzma_index_checks"></a><span class="ddoc_psymbol">lzma_index_checks</span>(const lzma_index* <i>i</i>);
</dt>
<dd>Get the types of integrity Checks
<p></p>
If lzma_index_stream_flags() is used to set the Stream Flags for
 every Stream, <a name="lzma_index_checks"></a><span class="ddoc_psymbol">lzma_index_checks</span>() can be used to get a bitmask to
 indicate which Check types have been used. It can be useful e.g. if
 showing the Check types to the user.
<p></p>

 The bitmask is 1 &lt;&lt; check_id, e.g. CRC32 is 1 &lt;&lt; 1 and SHA-256 is 1 &lt;&lt; 10.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_stream_padding"></a><span class="ddoc_psymbol">lzma_index_stream_padding</span>(lzma_index* <i>i</i>, lzma_vli <i>stream_padding</i>);
</dt>
<dd>Set the amount of Stream Padding
<p></p>
Set the amount of Stream Padding of the last (and typically the only)
 Stream in the lzma_index. This is needed when planning to do random-access
 reading within multiple concatenated Streams.
<p></p>

 By default, the amount of Stream Padding is assumed to be zero bytes.

<p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_DATA_ERROR: The file size would grow too big.
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_index_stream_count"></a><span class="ddoc_psymbol">lzma_index_stream_count</span>(const lzma_index* <i>i</i>);
</dt>
<dd>Get the number of Streams<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_index_block_count"></a><span class="ddoc_psymbol">lzma_index_block_count</span>(const lzma_index* <i>i</i>);
</dt>
<dd>Get the number of Blocks
<p></p>
This returns the total number of Blocks in lzma_index. To get number
 of Blocks in individual Streams, use lzma_index_iter.<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_index_size"></a><span class="ddoc_psymbol">lzma_index_size</span>(const lzma_index* <i>i</i>);
</dt>
<dd>Get the size of the Index field as bytes
<p></p>
This is needed to verify the Backward Size field in the Stream Footer.<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_index_stream_size"></a><span class="ddoc_psymbol">lzma_index_stream_size</span>(const lzma_index* <i>i</i>);
</dt>
<dd>Get the total size of the Stream
<p></p>
If multiple lzma_indexes have been combined, this works as if the Blocks
 were in a single Stream. This is useful if you are going to combine
 Blocks from multiple Streams into a single new Stream.<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_index_total_size"></a><span class="ddoc_psymbol">lzma_index_total_size</span>(const lzma_index* <i>i</i>);
</dt>
<dd>Get the total size of the Blocks
<p></p>
This doesn't include the Stream Header, Stream Footer, Stream Padding,
 or Index fields.<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_index_file_size"></a><span class="ddoc_psymbol">lzma_index_file_size</span>(const lzma_index* <i>i</i>);
</dt>
<dd>Get the total size of the file
<p></p>
When no lzma_indexes have been combined with lzma_index_cat() and there is
 no Stream Padding, this function is identical to lzma_index_stream_size().
 If multiple lzma_indexes have been combined, this includes also the headers
 of each separate Stream and the possible Stream Padding fields.<p></p>

</dd>
<dt class="d_decl">lzma_vli <a name="lzma_index_uncompressed_size"></a><span class="ddoc_psymbol">lzma_index_uncompressed_size</span>(const lzma_index* <i>i</i>);
</dt>
<dd>Get the uncompressed size of the file<p></p>

</dd>
<dt class="d_decl">void <a name="lzma_index_iter_init"></a><span class="ddoc_psymbol">lzma_index_iter_init</span>(lzma_index_iter* <i>iter</i>, const lzma_index* <i>i</i>);
</dt>
<dd>Initialize an iterator
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_index_iter* <i>iter</i></td>
<td valign=top>Pointer to a lzma_index_iter structure</td></tr>
<tr><td valign=top>lzma_index* <i>i</i></td>
<td valign=top>lzma_index to which the iterator will be associated
<p></p>

 This function associates the iterator with the given lzma_index, and calls
 lzma_index_iter_rewind() on the iterator.
<p></p>

 This function doesn't allocate any memory, thus there is no
 lzma_index_iter_end(). The iterator is valid as long as the
 associated lzma_index is valid, that is, until lzma_index_end() or
 using it as source in lzma_index_cat(). Specifically, lzma_index doesn't
 become invalid if new Blocks are added to it with lzma_index_append() or
 if it is used as the destination in lzma_index_cat().
<p></p>

 It is safe to make copies of an initialized lzma_index_iter, for example,
 to easily restart reading at some particular position.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void <a name="lzma_index_iter_rewind"></a><span class="ddoc_psymbol">lzma_index_iter_rewind</span>(lzma_index_iter* <i>iter</i>);
</dt>
<dd>Rewind the iterator
<p></p>
Rewind the iterator so that next call to lzma_index_iter_next() will
 return the first Block or Stream.<p></p>

</dd>
<dt class="d_decl">lzma_bool <a name="lzma_index_iter_next"></a><span class="ddoc_psymbol">lzma_index_iter_next</span>(lzma_index_iter* <i>iter</i>, lzma_index_iter_mode <i>mode</i>);
</dt>
<dd>Get the next Block or Stream
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_index_iter* <i>iter</i></td>
<td valign=top>Iterator initialized with lzma_index_iter_init()</td></tr>
<tr><td valign=top>lzma_index_iter_mode <i>mode</i></td>
<td valign=top>Specify what kind of information the caller wants
                      to get. See lzma_index_iter_mode for details.</td></tr>
</table><p></p>
<b>Returns:</b><br>If next Block or Stream matching the <i>mode</i> was found, *<i>iter</i>
              is updated and this function returns <b>false</b>. If no Block or
              Stream matching the <i>mode</i> is found, *<i>iter</i> is not modified
              and this function returns <b>true</b>. If <i>mode</i> is set to an unknown
              value, *<i>iter</i> is not modified and this function returns <b>true</b>.<p></p>

</dd>
<dt class="d_decl">lzma_bool <a name="lzma_index_iter_locate"></a><span class="ddoc_psymbol">lzma_index_iter_locate</span>(lzma_index_iter* <i>iter</i>, lzma_vli <i>target</i>);
</dt>
<dd>Locate a Block
<p></p>
If it is possible to seek in the .xz file, it is possible to parse
 the Index field(s) and use <a name="lzma_index_iter_locate"></a><span class="ddoc_psymbol">lzma_index_iter_locate</span>() to do random-access
 reading with granularity of Block size.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_index_iter* <i>iter</i></td>
<td valign=top>Iterator that was earlier initialized with
                      lzma_index_iter_init().</td></tr>
<tr><td valign=top>lzma_vli <i>target</i></td>
<td valign=top>Uncompressed <i>target</i> offset which the caller would
                      like to locate from the Stream
<p></p>

 If the <i>target</i> is smaller than the uncompressed size of the Stream (can be
 checked with lzma_index_uncompressed_size()):
  - Information about the Stream and Block containing the requested
    uncompressed offset is stored into *<i>iter</i>.
  - Internal state of the iterator is adjusted so that
    lzma_index_iter_next() can be used to read subsequent Blocks or Streams.
  - This function returns <b>false</b>.
<p></p>

 If <i>target</i> is greater than the uncompressed size of the Stream, *<i>iter</i>
 is not modified, and this function returns <b>true</b>.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_cat"></a><span class="ddoc_psymbol">lzma_index_cat</span>(lzma_index* <i>dest</i>, lzma_index* <i>src</i>, lzma_allocator* <i>allocator</i>);
</dt>
<dd>Concatenate lzma_indexes
<p></p>
Concatenating lzma_indexes is useful when doing random-access reading in
 multi-Stream .xz file, or when combining multiple Streams into single
 Stream.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_index* <i>dest</i></td>
<td valign=top>lzma_index after which <i>src</i> is appended</td></tr>
<tr><td valign=top>lzma_index* <i>src</i></td>
<td valign=top>lzma_index to be appended after <i>dest</i>. If this
                        function succeeds, the memory allocated for <i>src</i>
                        is freed or moved to be part of <i>dest</i>, and all
                        iterators pointing to <i>src</i> will become invalid.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>Custom memory <i>allocator</i>; can be NULL to use
                        malloc() and free().</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: lzma_indexes were concatenated successfully.
                <i>src</i> is now a dangling pointer.
              - LZMA_DATA_ERROR: *<i>dest</i> would grow too big.
              - LZMA_MEM_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_index* <a name="lzma_index_dup"></a><span class="ddoc_psymbol">lzma_index_dup</span>(const lzma_index* <i>i</i>, lzma_allocator* <i>allocator</i>);
</dt>
<dd>Duplicate lzma_index
<p></p>
<b>Returns:</b><br>A copy of the lzma_index, or NULL if memory allocation failed.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_encoder"></a><span class="ddoc_psymbol">lzma_index_encoder</span>(lzma_stream* <i>strm</i>, const lzma_index* <i>i</i>);
</dt>
<dd>Initialize .xz Index encoder
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream* <i>strm</i></td>
<td valign=top>Pointer to properly prepared lzma_stream</td></tr>
<tr><td valign=top>lzma_index* <i>i</i></td>
<td valign=top>Pointer to lzma_index which should be encoded.
<p></p>

 The valid `action' values for lzma_code() are LZMA_RUN and LZMA_FINISH.
 It is enough to use only one of them (you can choose freely; use LZMA_RUN
 to support liblzma versions older than 5.0.0).</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Initialization succeeded, continue with lzma_code().
              - LZMA_MEM_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_decoder"></a><span class="ddoc_psymbol">lzma_index_decoder</span>(lzma_stream* <i>strm</i>, lzma_index** <i>i</i>, ulong <i>memlimit</i>);
</dt>
<dd>Initialize .xz Index decoder
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream* <i>strm</i></td>
<td valign=top>Pointer to properly prepared lzma_stream</td></tr>
<tr><td valign=top>lzma_index** <i>i</i></td>
<td valign=top>The decoded Index will be made available via
                          this pointer. Initially this function will
                          set *<i>i</i> to NULL (the old value is ignored). If
                          decoding succeeds (lzma_code() returns
                          LZMA_STREAM_END), *<i>i</i> will be set to point
                          to a new lzma_index, which the application
                          has to later free with lzma_index_end().</td></tr>
<tr><td valign=top>ulong <i>memlimit</i></td>
<td valign=top>How much memory the resulting lzma_index is
                          allowed to require.
<p></p>

 The valid `action' values for lzma_code() are LZMA_RUN and LZMA_FINISH.
 It is enough to use only one of them (you can choose freely; use LZMA_RUN
 to support liblzma versions older than 5.0.0).</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Initialization succeeded, continue with lzma_code().
              - LZMA_MEM_ERROR
              - LZMA_MEMLIMIT_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_buffer_encode"></a><span class="ddoc_psymbol">lzma_index_buffer_encode</span>(const lzma_index* <i>i</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Single-call .xz Index encoder
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_index* <i>i</i></td>
<td valign=top>lzma_index to be encoded</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>The next byte will be written to out[*<i>out_pos</i>].
                        *<i>out_pos</i> is updated only if encoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>Size of the out buffer; the first byte into
                        which no data is written to is out[<i>out_size</i>].</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Encoding was successful.
              - LZMA_BUF_ERROR: Output buffer is too small. Use
                lzma_index_size() to find out how much output
                space is needed.
              - LZMA_PROG_ERROR

<p></p>
<b>Note:</b><br>
This function doesn't take allocator argument since all
              the internal data is allocated on stack.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_index_buffer_decode"></a><span class="ddoc_psymbol">lzma_index_buffer_decode</span>(lzma_index** <i>i</i>, ulong* <i>memlimit</i>, lzma_allocator* <i>allocator</i>, const ubyte* <i>in_</i>, uint* <i>in_pos</i>, size_t <i>in_size</i>);
</dt>
<dd>Single-call .xz Index decoder
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_index** <i>i</i></td>
<td valign=top>If decoding succeeds, *<i>i</i> will point to a new
                          lzma_index, which the application has to
                          later free with lzma_index_end(). If an error
                          occurs, *<i>i</i> will be NULL. The old value of *<i>i</i>
                          is always ignored and thus doesn't need to be
                          initialized by the caller.</td></tr>
<tr><td valign=top>ulong* <i>memlimit</i></td>
<td valign=top>Pointer to how much memory the resulting
                          lzma_index is allowed to require. The value
                          pointed by this pointer is modified if and only
                          if LZMA_MEMLIMIT_ERROR is returned.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>Pointer to lzma_allocator, or NULL to use malloc()</td></tr>
<tr><td valign=top>ubyte* <i>in_</i></td>
<td valign=top>Beginning of the input buffer</td></tr>
<tr><td valign=top>uint* <i>in_pos</i></td>
<td valign=top>The next byte will be read from in[*<i>in_pos</i>].
                          *<i>in_pos</i> is updated only if decoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>Size of the input buffer; the first byte that
                          won't be read is in[<i>in_size</i>].</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Decoding was successful.
              - LZMA_MEM_ERROR
              - LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.
                The minimum required <i>memlimit</i> value was stored to *<i>memlimit</i>.
              - LZMA_DATA_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
