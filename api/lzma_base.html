<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.base - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.base</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/base.d -->
Data types and functions used in many places in liblzma API
<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">alias <a name="lzma_bool"></a><span class="ddoc_psymbol">lzma_bool</span>;
</dt>
<dd>Boolean
<p></p>
This is here because C89 doesn't have stdbool.h. To set a value for
 variables having type <a name="lzma_bool"></a><span class="ddoc_psymbol">lzma_bool</span>, you can use
   - C99's `<b>true</b>' and `<b>false</b>' from stdbool.h;
   - C++'s internal `<b>true</b>' and `<b>false</b>'; or
   - integers one (<b>true</b>) and zero (<b>false</b>).<p></p>

</dd>
<dt class="d_decl">enum <a name="lzma_reserved_enum"></a><span class="ddoc_psymbol">lzma_reserved_enum</span>;
</dt>
<dd>Type of reserved enumeration variable in structures
<p></p>
To avoid breaking library ABI when new features are added, several
 structures contain extra variables that may be used in future. Since
 sizeof(enum) can be different than sizeof(int), and sizeof(enum) may
 even vary depending on the range of enumeration constants, we specify
 a separate type to be used for reserved enumeration variables. All
 enumeration constants in liblzma API will be non-negative and less
 than 128, which should guarantee that the ABI won't break even when
 new constants are added to existing enumerations.<p></p>

</dd>
<dt class="d_decl">enum <a name="lzma_ret"></a><span class="ddoc_psymbol">lzma_ret</span>;
</dt>
<dd>Return values used by several functions in liblzma
<p></p>
Check the descriptions of specific functions to find out which return
 values they can return. With some functions the return values may have
 more specific meanings than described here; those differences are
 described per-function basis.<p></p>

<dl><dt class="d_decl"><a name="LZMA_STREAM_END"></a><span class="ddoc_psymbol">LZMA_STREAM_END</span></dt>
<dd>Operation completed successfully<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_NO_CHECK"></a><span class="ddoc_psymbol">LZMA_NO_CHECK</span></dt>
<dd>End of stream was reached
<p></p>
In encoder, LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, or
 LZMA_FINISH was finished. In decoder, this indicates
 that all the data was successfully decoded.
<p></p>

 In all cases, when LZMA_STREAM_END is returned, the last
 output bytes should be picked from strm.next_out.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_UNSUPPORTED_CHECK"></a><span class="ddoc_psymbol">LZMA_UNSUPPORTED_CHECK</span></dt>
<dd>Input stream has no integrity check
<p></p>
This return value can be returned only if the
 LZMA_TELL_NO_CHECK flag was used when initializing
 the decoder. LZMA_NO_CHECK is just a warning, and
 the decoding can be continued normally.
<p></p>

 It is possible to call lzma_get_check() immediately after
 lzma_code has returned LZMA_NO_CHECK. The result will
 naturally be LZMA_CHECK_NONE, but the possibility to call
 lzma_get_check() may be convenient in some applications.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_GET_CHECK"></a><span class="ddoc_psymbol">LZMA_GET_CHECK</span></dt>
<dd>Cannot calculate the integrity check
<p></p>
The usage of this return value is different in encoders
 and decoders.
<p></p>

 Encoders can return this value only from the initialization
 function. If initialization fails with this value, the
 encoding cannot be done, because there's no way to produce
 output with the correct integrity check.
<p></p>

 Decoders can return this value only from lzma_code() and
 only if the LZMA_TELL_UNSUPPORTED_CHECK flag was used when
 initializing the decoder. The decoding can still be
 continued normally even if the check type is unsupported,
 but naturally the check will not be validated, and possible
 errors may go undetected.
<p></p>

 With decoder, it is possible to call lzma_get_check()
 immediately after lzma_code() has returned
 LZMA_UNSUPPORTED_CHECK. This way it is possible to find
 out what the unsupported Check ID was.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_MEM_ERROR"></a><span class="ddoc_psymbol">LZMA_MEM_ERROR</span></dt>
<dd>Integrity check type is now available
<p></p>
This value can be returned only by the lzma_code() function
 and only if the decoder was initialized with the
 LZMA_TELL_ANY_CHECK flag. LZMA_GET_CHECK tells the
 application that it may now call lzma_get_check() to find
 out the Check ID. This can be used, for example, to
 implement a decoder that accepts only files that have
 strong enough integrity check.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_MEMLIMIT_ERROR"></a><span class="ddoc_psymbol">LZMA_MEMLIMIT_ERROR</span></dt>
<dd>Cannot allocate memory
<p></p>
Memory allocation failed, or the size of the allocation
 would be greater than SIZE_MAX.
<p></p>

 Due to internal implementation reasons, the coding cannot
 be continued even if more memory were made available after
 LZMA_MEM_ERROR.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_FORMAT_ERROR"></a><span class="ddoc_psymbol">LZMA_FORMAT_ERROR</span></dt>
<dd>Memory usage limit was reached
<p></p>
Decoder would need more memory than allowed by the
 specified memory usage limit. To continue decoding,
 the memory usage limit has to be increased with
 lzma_memlimit_set().<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_OPTIONS_ERROR"></a><span class="ddoc_psymbol">LZMA_OPTIONS_ERROR</span></dt>
<dd>File format not recognized
<p></p>
The decoder did not recognize the input as supported file
 format. This error can occur, for example, when trying to
 decode .lzma format file with lzma_stream_decoder,
 because lzma_stream_decoder accepts only the .xz format.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_DATA_ERROR"></a><span class="ddoc_psymbol">LZMA_DATA_ERROR</span></dt>
<dd>Invalid or unsupported options
<p></p>
Invalid or unsupported options, for example
  - unsupported filter(s) or filter options; or
  - reserved bits set in headers (decoder only).
<p></p>

 Rebuilding liblzma with more features enabled, or
 upgrading to a newer version of liblzma may help.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_BUF_ERROR"></a><span class="ddoc_psymbol">LZMA_BUF_ERROR</span></dt>
<dd>Data is corrupt
<p></p>
The usage of this return value is different in encoders
 and decoders. In both encoder and decoder, the coding
 cannot continue after this error.
<p></p>

 Encoders return this if size limits of the target file
 format would be exceeded. These limits are huge, thus
 getting this error from an encoder is mostly theoretical.
 For example, the maximum compressed and uncompressed
 size of a .xz Stream is roughly 8 EiB (2^63 bytes).
<p></p>

 Decoders return this error if the input data is corrupt.
 This can mean, for example, invalid CRC32 in headers
 or invalid check of uncompressed data.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_PROG_ERROR"></a><span class="ddoc_psymbol">LZMA_PROG_ERROR</span></dt>
<dd>No progress is possible
<p></p>
This error code is returned when the coder cannot consume
 any new input and produce any new output. The most common
 reason for this error is that the input stream being
 decoded is truncated or corrupt.
<p></p>

 This error is not fatal. Coding can be continued normally
 by providing more input and/or more output space, if
 possible.
<p></p>

 Typically the first call to lzma_code() that can do no
 progress returns LZMA_OK instead of LZMA_BUF_ERROR. Only
 the second consecutive call doing no progress will return
 LZMA_BUF_ERROR. This is intentional.
<p></p>

 With zlib, Z_BUF_ERROR may be returned even if the
 application is doing nothing wrong, so apps will need
 to handle Z_BUF_ERROR specially. The above hack
 guarantees that liblzma never returns LZMA_BUF_ERROR
 to properly written applications unless the input file
 is truncated or corrupt. This should simplify the
 applications a little.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="lzma_action"></a><span class="ddoc_psymbol">lzma_action</span>;
</dt>
<dd>The `action' argument for lzma_code()
<p></p>
After the first use of LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, or LZMA_FINISH,
 the same `action' must is used until lzma_code() returns LZMA_STREAM_END.
 Also, the amount of input (that is, strm.avail_in) must not be modified
 by the application until lzma_code() returns LZMA_STREAM_END. Changing the
 `action' or modifying the amount of input will make lzma_code() return
 LZMA_PROG_ERROR.<p></p>

<dl><dt class="d_decl"><a name="LZMA_SYNC_FLUSH"></a><span class="ddoc_psymbol">LZMA_SYNC_FLUSH</span></dt>
<dd>Continue coding
<p></p>
<b>Encoder:</b><br>
Encode as much input as possible. Some internal
 buffering will probably be done (depends on the filter
 chain in use), which causes latency: the input used won't
 usually be decodeable from the output of the same
 lzma_code() call.

<p></p>
<b>Decoder:</b><br>
Decode as much input as possible and produce as
 much output as possible.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_FULL_FLUSH"></a><span class="ddoc_psymbol">LZMA_FULL_FLUSH</span></dt>
<dd>Make all the input available at output
<p></p>
Normally the encoder introduces some latency.
 LZMA_SYNC_FLUSH forces all the buffered data to be
 available at output without resetting the internal
 state of the encoder. This way it is possible to use
 compressed stream for example for communication over
 network.
<p></p>

 Only some filters support LZMA_SYNC_FLUSH. Trying to use
 LZMA_SYNC_FLUSH with filters that don't support it will
 make lzma_code() return LZMA_OPTIONS_ERROR. For example,
 LZMA1 doesn't support LZMA_SYNC_FLUSH but LZMA2 does.
<p></p>

 Using LZMA_SYNC_FLUSH very often can dramatically reduce
 the compression ratio. With some filters (for example,
 LZMA2), fine-tuning the compression options may help
 mitigate this problem significantly (for example,
 match finder with LZMA2).
<p></p>

 Decoders don't support LZMA_SYNC_FLUSH.<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_FINISH"></a><span class="ddoc_psymbol">LZMA_FINISH</span></dt>
<dd>Finish encoding of the current Block
<p></p>
All the input data going to the current Block must have
 been given to the encoder (the last bytes can still be
 pending in* next_in). Call lzma_code() with LZMA_FULL_FLUSH
 until it returns LZMA_STREAM_END. Then continue normally
 with LZMA_RUN or finish the Stream with <a name="LZMA_FINISH"></a><span class="ddoc_psymbol">LZMA_FINISH</span>.
<p></p>

 This action is currently supported only by Stream encoder
 and easy encoder (which uses Stream encoder). If there is
 no unfinished Block, no empty Block is created.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="lzma_allocator"></a><span class="ddoc_psymbol">lzma_allocator</span>;
</dt>
<dd>Custom functions for memory handling
<p></p>
A pointer to <a name="lzma_allocator"></a><span class="ddoc_psymbol">lzma_allocator</span> may be passed via lzma_stream structure
 to liblzma, and some advanced functions take a pointer to <a name="lzma_allocator"></a><span class="ddoc_psymbol">lzma_allocator</span>
 as a separate function argument. The library will use the functions
 specified in <a name="lzma_allocator"></a><span class="ddoc_psymbol">lzma_allocator</span> for memory handling instead of the default
 malloc() and free(). C++ users should note that the custom memory
 handling functions must not throw exceptions.
<p></p>

 liblzma doesn't make an internal copy of <a name="lzma_allocator"></a><span class="ddoc_psymbol">lzma_allocator</span>. Thus, it is
 OK to change these function pointers in the middle of the coding
 process, but obviously it must be done carefully to make sure that the
 replacement `free' can deallocate memory allocated by the earlier
 `alloc' function(s).<p></p>

<dl><dt class="d_decl">void* function(void* opaque, uint nmemb, uint size) <a name="alloc"></a><span class="ddoc_psymbol">alloc</span>;
</dt>
<dd>Pointer to a custom memory allocation function
<p></p>
If you don't want a custom allocator, but still want
 custom free(), set this to NULL and liblzma will use
 the standard malloc().
<p></p>

 The allocator should not waste time zeroing the allocated buffers.
 This is not only about speed, but also memory usage, since the
 operating system kernel doesn't necessarily allocate the requested
 memory in physical memory until it is actually used. With small
 input files, liblzma may actually need only a fraction of the
 memory that it requested for allocation.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>opaque</td>
<td valign=top>lzma_allocator.opaque (see below)</td></tr>
<tr><td valign=top>nmemb</td>
<td valign=top>Number of elements like in calloc(). liblzma
                      will always set nmemb to 1, so it is safe to
                      ignore nmemb in a custom allocator if you like.
                      The nmemb argument exists only for
                      compatibility with zlib and libbzip2.</td></tr>
<tr><td valign=top>size</td>
<td valign=top>Size of an element in bytes.
                      liblzma never sets this to zero.</td></tr>
</table><p></p>
<b>Returns:</b><br>Pointer to the beginning of a memory block of
 `size' bytes, or NULL if allocation fails
 for some reason. When allocation fails, functions
 of liblzma return LZMA_MEM_ERROR.

<p></p>
<b>Note:</b><br>
LZMA_MEM_ERROR is also used when the size of the
 allocation would be greater than SIZE_MAX. Thus,
 don't assume that the custom allocator must have
 returned NULL if some function from liblzma
 returns LZMA_MEM_ERROR.<p></p>

</dd>
<dt class="d_decl">void function(void* opaque, void* ptr) <a name="free"></a><span class="ddoc_psymbol">free</span>;
</dt>
<dd>Pointer to a custom memory freeing function
<p></p>
If you don't want a custom freeing function, but still
 want a custom allocator, set this to NULL and liblzma
 will use the standard <a name="free"></a><span class="ddoc_psymbol">free</span>().

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>opaque</td>
<td valign=top>lzma_allocator.opaque (see below)</td></tr>
<tr><td valign=top>ptr</td>
<td valign=top>Pointer returned by lzma_allocator.alloc(),
                      or when it is set to NULL, a pointer returned
                      by the standard malloc().</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">void* <a name="opaque"></a><span class="ddoc_psymbol">opaque</span>;
</dt>
<dd>Pointer passed to .alloc() and .free()
<p></p>
<a name="opaque"></a><span class="ddoc_psymbol">opaque</span> is passed as the first argument to lzma_allocator.alloc()
 and lzma_allocator.free(). This intended to ease implementing
 custom memory allocation functions for use with liblzma.
<p></p>

 If you don't need this, you should set this to NULL.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="lzma_internal"></a><span class="ddoc_psymbol">lzma_internal</span>;
</dt>
<dd>Internal data structure
<p></p>
The contents of this structure is not visible outside the library.<p></p>

</dd>
<dt class="d_decl">struct <a name="lzma_stream"></a><span class="ddoc_psymbol">lzma_stream</span>;
</dt>
<dd>Passing data to and from liblzma
<p></p>
The <a name="lzma_stream"></a><span class="ddoc_psymbol">lzma_stream</span> structure is used for
  - passing pointers to input and output buffers to liblzma;
  - defining custom memory hander functions; and
  - holding a pointer to coder-specific internal data structures.
<p></p>

 Typical usage:
<p></p>

  - After allocating <a name="lzma_stream"></a><span class="ddoc_psymbol">lzma_stream</span> (on stack or with malloc()), it must be
    initialized to LZMA_STREAM_INIT (see LZMA_STREAM_INIT for details).
<p></p>

  - Initialize a coder to the <a name="lzma_stream"></a><span class="ddoc_psymbol">lzma_stream</span>, for example by using
    lzma_easy_encoder() or lzma_auto_decoder(). Some notes:
      - In contrast to zlib, strm.next_in and strm.next_out are
        ignored by all initialization functions, thus it is safe
        to not initialize them yet.
      - The initialization functions always set strm.total_in and
        strm.total_out to zero.
      - If the initialization function fails, no memory is left allocated
        that would require freeing with lzma_end() even if some memory was
        associated with the <a name="lzma_stream"></a><span class="ddoc_psymbol">lzma_stream</span> structure when the initialization
        function was called.
<p></p>

  - Use lzma_code() to do the actual work.
<p></p>

  - Once the coding has been finished, the existing <a name="lzma_stream"></a><span class="ddoc_psymbol">lzma_stream</span> can be
    reused. It is OK to reuse <a name="lzma_stream"></a><span class="ddoc_psymbol">lzma_stream</span> with different initialization
    function without calling lzma_end() first. Old allocations are
    automatically freed.
<p></p>

  - Finally, use lzma_end() to free the allocated memory. lzma_end() never
    frees the <a name="lzma_stream"></a><span class="ddoc_psymbol">lzma_stream</span> structure itself.
<p></p>

 Application may modify the values of total_in and total_out as it wants.
 They are updated by liblzma to match the amount of data read and
 written, but aren't used for anything else.<p></p>

<dl><dt class="d_decl">const(ubyte)* <a name="next_in"></a><span class="ddoc_psymbol">next_in</span>;
</dt>
<dd>Pointer to the next input byte. <p></p>

</dd>
<dt class="d_decl">size_t <a name="avail_in"></a><span class="ddoc_psymbol">avail_in</span>;
</dt>
<dd>Number of available input bytes in next_in. <p></p>

</dd>
<dt class="d_decl">ulong <a name="total_in"></a><span class="ddoc_psymbol">total_in</span>;
</dt>
<dd>Total number of bytes read by liblzma. <p></p>

</dd>
<dt class="d_decl">ubyte* <a name="next_out"></a><span class="ddoc_psymbol">next_out</span>;
</dt>
<dd>Pointer to the next output position. <p></p>

</dd>
<dt class="d_decl">size_t <a name="avail_out"></a><span class="ddoc_psymbol">avail_out</span>;
</dt>
<dd>Amount of free space in next_out. <p></p>

</dd>
<dt class="d_decl">ulong <a name="total_out"></a><span class="ddoc_psymbol">total_out</span>;
</dt>
<dd>Total number of bytes written by liblzma. <p></p>

</dd>
<dt class="d_decl">lzma_allocator* <a name="allocator"></a><span class="ddoc_psymbol">allocator</span>;
</dt>
<dd>Custom memory allocation functions
<p></p>
In most cases this is NULL which makes liblzma use
 the standard malloc() and free().<p></p>

</dd>
<dt class="d_decl">lzma_internal* <a name="internal"></a><span class="ddoc_psymbol">internal</span>;
</dt>
<dd>Internal state is not visible to applications. <p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">lzma_ret <a name="lzma_code"></a><span class="ddoc_psymbol">lzma_code</span>(lzma_stream* <i>strm</i>, lzma_action <i>action</i>);
</dt>
<dd>Encode or decode data
<p></p>
Once the lzma_stream has been successfully initialized (e.g. with
 lzma_stream_encoder()), the actual encoding or decoding is done
 using this function. The application has to update <i>strm</i>.next_in,
 <i>strm</i>.avail_in, <i>strm</i>.next_out, and <i>strm</i>.avail_out to pass input
 to and get output from liblzma.
<p></p>

 See the description of the coder-specific initialization function to find
 out what `<i>action</i>' values are supported by the coder.<p></p>

</dd>
<dt class="d_decl">void <a name="lzma_end"></a><span class="ddoc_psymbol">lzma_end</span>(lzma_stream* <i>strm</i>);
</dt>
<dd>Free memory allocated for the coder data structures
<p></p>
After <a name="lzma_end"></a><span class="ddoc_psymbol">lzma_end</span>(<i>strm</i>), <i>strm</i>.internal is guaranteed to be NULL. No other
 members of the lzma_stream structure are touched.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream* <i>strm</i></td>
<td valign=top>Pointer to lzma_stream that is at least initialized
                      with LZMA_STREAM_INIT.</td></tr>
</table><p></p>
<b>Note:</b><br>
zlib indicates an error if application end()s unfinished
              stream structure. liblzma doesn't do this, and assumes that
              application knows what it is doing.<p></p>

</dd>
<dt class="d_decl">ulong <a name="lzma_memusage"></a><span class="ddoc_psymbol">lzma_memusage</span>(const lzma_stream* <i>strm</i>);
</dt>
<dd>Get the memory usage of decoder filter chain
<p></p>
This function is currently supported only when *<i>strm</i> has been initialized
 with a function that takes a memlimit argument. With other functions, you
 should use e.g. lzma_raw_encoder_memusage() or lzma_raw_decoder_memusage()
 to estimate the memory requirements.
<p></p>

 This function is useful e.g. after LZMA_MEMLIMIT_ERROR to find out how big
 the memory usage limit should have been to decode the input. Note that
 this may give misleading information if decoding .xz Streams that have
 multiple Blocks, because each Block can have different memory requirements.

<p></p>
<b>Returns:</b><br>How much memory is currently allocated for the filter
              decoders. If no filter chain is currently allocated,
              some non-zero value is still returned, which is less than
              or equal to what any filter chain would indicate as its
              memory requirement.
<p></p>

              If this function isn't supported by *<i>strm</i> or some other error
              occurs, zero is returned.<p></p>

</dd>
<dt class="d_decl">ulong <a name="lzma_memlimit_get"></a><span class="ddoc_psymbol">lzma_memlimit_get</span>(const lzma_stream* <i>strm</i>);
</dt>
<dd>Get the current memory usage limit
<p></p>
This function is supported only when *<i>strm</i> has been initialized with
 a function that takes a memlimit argument.

<p></p>
<b>Returns:</b><br>On success, the current memory usage limit is returned
              (always non-zero). On error, zero is returned.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_memlimit_set"></a><span class="ddoc_psymbol">lzma_memlimit_set</span>(lzma_stream* <i>strm</i>, ulong <i>memlimit</i>);
</dt>
<dd>Set the memory usage limit
<p></p>
This function is supported only when *<i>strm</i> has been initialized with
 a function that takes a <i>memlimit</i> argument.

<p></p>
<b>Returns:</b><br>- LZMA_OK: New memory usage limit successfully set.
              - LZMA_MEMLIMIT_ERROR: The new limit is too small.
                The limit was not changed.
              - LZMA_PROG_ERROR: Invalid arguments, e.g. *<i>strm</i> doesn't
                support memory usage limit or <i>memlimit</i> was zero.<p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
