<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.vli - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.vli</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/vli.d -->
Variable-length integer handling
<p></p>
In the .xz format, most integers are encoded in a variable-length
 representation, which is sometimes called little endian base-128 encoding.
 This saves space when smaller values are more likely than bigger values.
<p></p>

 The encoding scheme encodes seven bits to every byte, using minimum
 number of bytes required to represent the given value. Encodings that use
 non-minimum number of bytes are invalid, thus every integer has exactly
 one encoded representation. The maximum number of bits in a VLI is 63,
 thus the <a name="vli"></a><span class="ddoc_psymbol">vli</span> argument must be less than or equal to UINT64_MAX / 2. You
 should use LZMA_VLI_MAX for clarity.

<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">ulong <a name="LZMA_VLI_MAX"></a><span class="ddoc_psymbol">LZMA_VLI_MAX</span>;
</dt>
<dd>Maximum supported value of a variable-length integer<p></p>

</dd>
<dt class="d_decl">ulong <a name="LZMA_VLI_UNKNOWN"></a><span class="ddoc_psymbol">LZMA_VLI_UNKNOWN</span>;
</dt>
<dd>VLI value to denote that the value is unknown<p></p>

</dd>
<dt class="d_decl">int <a name="LZMA_VLI_BYTES_MAX"></a><span class="ddoc_psymbol">LZMA_VLI_BYTES_MAX</span>;
</dt>
<dd>Maximum supported encoded length of variable length integers<p></p>

</dd>
<dt class="d_decl">alias <a name="lzma_vli"></a><span class="ddoc_psymbol">lzma_vli</span>;
</dt>
<dd>VLI constant suffix
 
<p></p>

 Variable-length integer type
<p></p>
Valid VLI values are in the range [0, LZMA_VLI_MAX]. Unknown value is
 indicated with LZMA_VLI_UNKNOWN, which is the maximum value of the
 underlaying integer type.
<p></p>

 <a name="lzma_vli"></a><span class="ddoc_psymbol">lzma_vli</span> will be uint64_t for the foreseeable future. If a bigger size
 is needed in the future, it is guaranteed that 2 * LZMA_VLI_MAX will
 not overflow <a name="lzma_vli"></a><span class="ddoc_psymbol">lzma_vli</span>. This simplifies integer overflow detection.<p></p>

</dd>
<dt class="d_decl">bool <a name="lzma_vli_is_valid"></a><span class="ddoc_psymbol">lzma_vli_is_valid</span>(lzma_vli <i>vli</i>);
</dt>
<dd>Validate a variable-length integer
<p></p>
This is useful to test that application has given acceptable values
 for example in the uncompressed_size and compressed_size variables.
<p></p>

 \return      True if the integer is representable as VLI or if it
              indicates unknown value.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_vli_encode"></a><span class="ddoc_psymbol">lzma_vli_encode</span>(lzma_vli <i>vli</i>, uint* <i>vli_pos</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Encode a variable-length integer
<p></p>
This function has two modes: single-call and multi-call. Single-call mode
 encodes the whole integer at once; it is an error if the output buffer is
 too small. Multi-call mode saves the position in *<i>vli_pos</i>, and thus it is
 possible to continue encoding if the buffer becomes full before the whole
 integer has been encoded.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_vli <i>vli</i></td>
<td valign=top>Integer to be encoded</td></tr>
<tr><td valign=top>uint* <i>vli_pos</i></td>
<td valign=top>How many VLI-encoded bytes have already been written
                        out. When starting to encode a new integer in
                        multi-call mode, *<i>vli_pos</i> must be set to zero.
                        To use single-call encoding, set <i>vli_pos</i> to NULL.</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>The next byte will be written to out[*<i>out_pos</i>].</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>Size of the out buffer; the first byte into
                        which no data is written to is out[<i>out_size</i>].</td></tr>
</table><p></p>
<b>Returns:</b><br>Slightly different return values are used in multi-call and
              single-call modes.
<p></p>

              Single-call (<i>vli_pos</i> == NULL):
              - LZMA_OK: Integer successfully encoded.
              - LZMA_PROG_ERROR: Arguments are not sane. This can be due
                to too little output space; single-call mode doesn't use
                LZMA_BUF_ERROR, since the application should have checked
                the encoded size with lzma_vli_size().
<p></p>

              Multi-call (<i>vli_pos</i> != NULL):
              - LZMA_OK: So far all OK, but the integer is not
                completely written out yet.
              - LZMA_STREAM_END: Integer successfully encoded.
              - LZMA_BUF_ERROR: No output space was provided.
              - LZMA_PROG_ERROR: Arguments are not sane.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_vli_decode"></a><span class="ddoc_psymbol">lzma_vli_decode</span>(ulong* <i>vli</i>, uint* <i>vli_pos</i>, const(ubyte)* <i>in_</i>, uint* <i>in_pos</i>, size_t <i>in_size</i>);
</dt>
<dd>Decode a variable-length integer
<p></p>
Like lzma_vli_encode(), this function has single-call and multi-call modes.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>ulong* <i>vli</i></td>
<td valign=top>Pointer to decoded integer. The decoder will
                        initialize it to zero when *<i>vli_pos</i> == 0, so
                        application isn't required to initialize *<i>vli</i>.</td></tr>
<tr><td valign=top>uint* <i>vli_pos</i></td>
<td valign=top>How many bytes have already been decoded. When
                        starting to decode a new integer in multi-call
                        mode, *<i>vli_pos</i> must be initialized to zero. To
                        use single-call decoding, set <i>vli_pos</i> to NULL.</td></tr>
<tr><td valign=top>const(ubyte)* <i>in_</i></td>
<td valign=top>Beginning of the input buffer</td></tr>
<tr><td valign=top>uint* <i>in_pos</i></td>
<td valign=top>The next byte will be read from in[*<i>in_pos</i>].</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>Size of the input buffer; the first byte that
                        won't be read is in[<i>in_size</i>].</td></tr>
</table><p></p>
<b>Returns:</b><br>Slightly different return values are used in multi-call and
              single-call modes.
<p></p>

              Single-call (<i>vli_pos</i> == NULL):
              - LZMA_OK: Integer successfully decoded.
              - LZMA_DATA_ERROR: Integer is corrupt. This includes hitting
                the end of the input buffer before the whole integer was
                decoded; providing no input at all will use LZMA_DATA_ERROR.
              - LZMA_PROG_ERROR: Arguments are not sane.
<p></p>

              Multi-call (<i>vli_pos</i> != NULL):
              - LZMA_OK: So far all OK, but the integer is not
                completely decoded yet.
              - LZMA_STREAM_END: Integer successfully decoded.
              - LZMA_DATA_ERROR: Integer is corrupt.
              - LZMA_BUF_ERROR: No input was provided.
              - LZMA_PROG_ERROR: Arguments are not sane.<p></p>

</dd>
<dt class="d_decl">uint <a name="lzma_vli_size"></a><span class="ddoc_psymbol">lzma_vli_size</span>(lzma_vli <i>vli</i>);
</dt>
<dd>Get the number of bytes required to encode a VLI
<p></p>
Returns      Number of bytes on success (1-9). If <i>vli</i> isn't valid,
              zero is returned.<p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
