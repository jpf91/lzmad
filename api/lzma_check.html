<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.check - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.check</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/check.d -->
Integrity checks
<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">enum <a name="lzma_check"></a><span class="ddoc_psymbol">lzma_check</span>;
</dt>
<dd>Type of the integrity check (Check ID)
<p></p>
The .xz format supports multiple types of checks that are calculated
 from the uncompressed data. They vary in both speed and ability to
 detect errors.<p></p>

<dl><dt class="d_decl"><a name="LZMA_CHECK_NONE"></a><span class="ddoc_psymbol">LZMA_CHECK_NONE</span></dt>
<dd>No Check is calculated.
<p></p>
Size of the Check field: 0 bytes<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_CHECK_CRC32"></a><span class="ddoc_psymbol">LZMA_CHECK_CRC32</span></dt>
<dd>CRC32 using the polynomial from the IEEE 802.3 standard
<p></p>
Size of the Check field: 4 bytes<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_CHECK_CRC64"></a><span class="ddoc_psymbol">LZMA_CHECK_CRC64</span></dt>
<dd>CRC64 using the polynomial from the ECMA-182 standard
<p></p>
Size of the Check field: 8 bytes<p></p>

</dd>
<dt class="d_decl"><a name="LZMA_CHECK_SHA256"></a><span class="ddoc_psymbol">LZMA_CHECK_SHA256</span></dt>
<dd>SHA-256
<p></p>
Size of the Check field: 32 bytes<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl">int <a name="LZMA_CHECK_ID_MAX"></a><span class="ddoc_psymbol">LZMA_CHECK_ID_MAX</span>;
</dt>
<dd>Maximum valid Check ID
<p></p>
The .xz file format specification specifies 16 Check IDs (0-15). Some
 of them are only reserved, that is, no actual Check algorithm has been
 assigned. When decoding, liblzma still accepts unknown Check IDs for
 future compatibility. If a valid but unsupported Check ID is detected,
 liblzma can indicate a warning; see the flags LZMA_TELL_NO_CHECK,
 LZMA_TELL_UNSUPPORTED_CHECK, and LZMA_TELL_ANY_CHECK in container.h.<p></p>

</dd>
<dt class="d_decl">lzma_bool <a name="lzma_check_is_supported"></a><span class="ddoc_psymbol">lzma_check_is_supported</span>(lzma_check <i>check</i>);
</dt>
<dd>Test if the given Check ID is supported
<p></p>
Return <b>true</b> if the given Check ID is supported by this liblzma build.
 Otherwise <b>false</b> is returned. It is safe to call this with a value that
 is not in the range [0, 15]; in that case the return value is always <b>false</b>.
<p></p>

 You can assume that LZMA_CHECK_NONE and LZMA_CHECK_CRC32 are always
 supported (even if liblzma is built with limited features).<p></p>

</dd>
<dt class="d_decl">uint <a name="lzma_check_size"></a><span class="ddoc_psymbol">lzma_check_size</span>(lzma_check <i>check</i>);
</dt>
<dd>Get the size of the Check field with the given Check ID
<p></p>
Although not all Check IDs have a <i>check</i> algorithm associated, the size of
 every Check is already frozen. This function returns the size (in bytes) of
 the Check field with the specified Check ID. The values are:
 { 0, 4, 4, 4, 8, 8, 8, 16, 16, 16, 32, 32, 32, 64, 64, 64 }
<p></p>

 If the argument is not in the range [0, 15], UINT32_MAX is returned.<p></p>

</dd>
<dt class="d_decl">int <a name="LZMA_CHECK_SIZE_MAX"></a><span class="ddoc_psymbol">LZMA_CHECK_SIZE_MAX</span>;
</dt>
<dd>Maximum size of a Check field<p></p>

</dd>
<dt class="d_decl">uint <a name="lzma_crc32"></a><span class="ddoc_psymbol">lzma_crc32</span>(const(ubyte)* <i>buf</i>, size_t <i>size</i>, uint <i>crc</i>);
</dt>
<dd>Calculate CRC32
<p></p>
Calculate CRC32 using the polynomial from the IEEE 802.3 standard.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>const(ubyte)* <i>buf</i></td>
<td valign=top>Pointer to the input buffer</td></tr>
<tr><td valign=top>size_t <i>size</i></td>
<td valign=top>Size of the input buffer</td></tr>
<tr><td valign=top>uint <i>crc</i></td>
<td valign=top>Previously returned CRC value. This is used to
                      calculate the CRC of a big buffer in smaller chunks.
                      Set to zero when starting a new calculation.</td></tr>
</table><p></p>
<b>Returns:</b><br>Updated CRC value, which can be passed to this function
              again to continue CRC calculation.<p></p>

</dd>
<dt class="d_decl">ulong <a name="lzma_crc64"></a><span class="ddoc_psymbol">lzma_crc64</span>(const(ubyte)* <i>buf</i>, size_t <i>size</i>, ulong <i>crc</i>);
</dt>
<dd>\brief       Calculate CRC64
<p></p>
Calculate CRC64 using the polynomial from the ECMA-182 standard.
<p></p>

 This function is used similarly to lzma_crc32(). See its documentation.<p></p>

</dd>
<dt class="d_decl">lzma_check <a name="lzma_get_check"></a><span class="ddoc_psymbol">lzma_get_check</span>(const lzma_stream* <i>strm</i>);
</dt>
<dd>Get the type of the integrity check
<p></p>
This function can be called only immediately after lzma_code() has
 returned LZMA_NO_CHECK, LZMA_UNSUPPORTED_CHECK, or LZMA_GET_CHECK.
 Calling this function in any other situation has undefined behavior.<p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
