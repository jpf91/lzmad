<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en'>

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>lzma_.container - liblzma </title>
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="../js/hyphenate_selectively.js" type="text/javascript"></script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="header">
		<a id="d-language" href="https://github.com/jpf91/liblzmad">liblzma bindings</a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
</div>
    
<div class="navblock">
    <h2><a href="" title="">Main module</a></h2>
    <ul><li><a href="lzma.html" title="">lzma</a></li>
    </ul>
    <h2><a href="" title="">lzma_</a></h2>
    <ul><li><a href="lzma_base.html" title="">lzma_.base</a></li>
	<li><a href="lzma_bcj.html" title="">lzma_.bcj</a></li>
	<li><a href="lzma_block.html" title="">lzma_.block</a></li>
	<li><a href="lzma_check.html" title="">lzma_.check</a></li>
	<li><a href="lzma_container.html" title="">lzma_.container</a></li>
        <li><a href="lzma_delta.html" title="">lzma_.delta</a></li>
        <li><a href="lzma_filter.html" title="">lzma_.filter</a></li>
	<li><a href="lzma_hardware.html" title="">lzma_.hardware</a></li>
	<li><a href="lzma_index.html" title="">lzma_.index</a></li>
	<li><a href="lzma_index_hash.html" title="">lzma_.index_hash</a></li>
	<li><a href="lzma_lzma.html" title="">lzma_.lzma</a></li>
	<li><a href="lzma_stream_flags.html" title="">lzma_.stream_flags</a></li>
        <li><a href="lzma_version_.html" title="">lzma_.version_</a></li>
        <li><a href="lzma_vli.html" title="">lzma_.vli</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1>lzma_.container</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from lzma_/container.d -->
File formats
<p></p>
<b>Source:</b><br>

<p></p>
<b>Author:</b><br>
Lasse Collin (original liblzma author),
         Johannes Pfau (D bindings)
<p></p>
<b>License:</b><br>public domain<p></p>

<dl><dt class="d_decl">uint <a name="LZMA_PRESET_DEFAULT"></a><span class="ddoc_psymbol">LZMA_PRESET_DEFAULT</span>;
</dt>
<dd>Default compression preset
<p></p>
It's not straightforward to recommend a default preset, because in some
 cases keeping the resource usage relatively low is more important that
 getting the maximum compression ratio.<p></p>

</dd>
<dt class="d_decl">uint <a name="LZMA_PRESET_LEVEL_MASK"></a><span class="ddoc_psymbol">LZMA_PRESET_LEVEL_MASK</span>;
</dt>
<dd>Mask for preset level
<p></p>
This is useful only if you need to extract the level from the preset
 variable. That should be rare.<p></p>

</dd>
<dt class="d_decl">uint <a name="LZMA_PRESET_EXTREME"></a><span class="ddoc_psymbol">LZMA_PRESET_EXTREME</span>;
</dt>
<dd>Extreme compression preset
<p></p>
This flag modifies the preset to make the encoding significantly slower
 while improving the compression ratio only marginally. This is useful
 when you don't mind wasting time to get as small result as possible.
<p></p>

 This flag doesn't affect the memory usage requirements of the decoder (at
 least not significantly). The memory usage of the encoder may be increased
 a little but only at the lowest preset levels (0-3).<p></p>

</dd>
<dt class="d_decl">ulong <a name="lzma_easy_encoder_memusage"></a><span class="ddoc_psymbol">lzma_easy_encoder_memusage</span>(uint <i>preset</i>);
</dt>
<dd>Calculate approximate memory usage of easy encoder
<p></p>
This function is a wrapper for lzma_raw_encoder_memusage().

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>uint <i>preset</i></td>
<td valign=top>Compression <i>preset</i> (level and possible flags)</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">ulong <a name="lzma_easy_decoder_memusage"></a><span class="ddoc_psymbol">lzma_easy_decoder_memusage</span>(uint <i>preset</i>);
</dt>
<dd>Calculate approximate decoder memory usage of a <i>preset</i>
<p></p>
This function is a wrapper for lzma_raw_decoder_memusage().

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>uint <i>preset</i></td>
<td valign=top>Compression <i>preset</i> (level and possible flags)</td></tr>
</table><p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_easy_encoder"></a><span class="ddoc_psymbol">lzma_easy_encoder</span>(lzma_stream* <i>strm</i>, uint <i>preset</i>, lzma_check <i>check</i>);
</dt>
<dd>Initialize .xz Stream encoder using a <i>preset</i> number
<p></p>
This function is intended for those who just want to use the basic features
 if liblzma (that is, most developers out there).
<p></p>

 If initialization fails (return value is not LZMA_OK), all the memory
 allocated for *<i>strm</i> by liblzma is always freed. Thus, there is no need
 to call lzma_end() after failed initialization.
<p></p>

 If initialization succeeds, use lzma_code() to do the actual encoding.
 Valid values for `action' (the second argument of lzma_code()) are
 LZMA_RUN, LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, and LZMA_FINISH. In future,
 there may be compression levels or flags that don't support LZMA_SYNC_FLUSH.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream* <i>strm</i></td>
<td valign=top>Pointer to lzma_stream that is at least initialized
                      with LZMA_STREAM_INIT.</td></tr>
<tr><td valign=top>uint <i>preset</i></td>
<td valign=top>Compression <i>preset</i> to use. A <i>preset</i> consist of level
                      number and zero or more flags. Usually flags aren't
                      used, so <i>preset</i> is simply a number [0, 9] which match
                      the options -0 ... -9 of the xz command line tool.
                      Additional flags can be be set using bitwise-or with
                      the <i>preset</i> level number, e.g. 6 | LZMA_PRESET_EXTREME.</td></tr>
<tr><td valign=top>lzma_check <i>check</i></td>
<td valign=top>Integrity <i>check</i> type to use. See <i>check</i>.h for available
                      checks. The xz command line tool defaults to
                      LZMA_CHECK_CRC64, which is a good choice if you are
                      unsure. LZMA_CHECK_CRC32 is good too as long as the
                      uncompressed file is not many gigabytes.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Initialization succeeded. Use lzma_code() to
                encode your data.
              - LZMA_MEM_ERROR: Memory allocation failed.
              - LZMA_OPTIONS_ERROR: The given compression <i>preset</i> is not
                supported by this build of liblzma.
              - LZMA_UNSUPPORTED_CHECK: The given <i>check</i> type is not
                supported by this liblzma build.
              - LZMA_PROG_ERROR: One or more of the parameters have values
                that will never be valid. For example, <i>strm</i> == NULL.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_easy_buffer_encode"></a><span class="ddoc_psymbol">lzma_easy_buffer_encode</span>(uint <i>preset</i>, lzma_check <i>check</i>, lzma_allocator* <i>allocator</i>, const(ubyte)* <i>in_</i>, size_t <i>in_size</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Single-call .xz Stream encoding using a <i>preset</i> number
<p></p>
The maximum required output buffer size can be calculated with
 lzma_stream_buffer_bound().

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>uint <i>preset</i></td>
<td valign=top>Compression <i>preset</i> to use. See the description
                          in lzma_easy_encoder().</td></tr>
<tr><td valign=top>lzma_check <i>check</i></td>
<td valign=top>Type of the integrity <i>check</i> to calculate from
                          uncompressed data.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>lzma_allocator for custom <i>allocator</i> functions.
                          Set to NULL to use malloc() and free().</td></tr>
<tr><td valign=top>const(ubyte)* <i>in_</i></td>
<td valign=top>Beginning of the input buffer</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>Size of the input buffer</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>The next byte will be written to out[*<i>out_pos</i>].
                          *<i>out_pos</i> is updated only if encoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>Size of the out buffer; the first byte into
                          which no data is written to is out[<i>out_size</i>].</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Encoding was successful.
              - LZMA_BUF_ERROR: Not enough output buffer space.
              - LZMA_OPTIONS_ERROR
              - LZMA_MEM_ERROR
              - LZMA_DATA_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_stream_encoder"></a><span class="ddoc_psymbol">lzma_stream_encoder</span>(lzma_stream* <i>strm</i>, const lzma_filter* <i>filters</i>, lzma_check <i>check</i>);
</dt>
<dd>Initialize .xz Stream encoder using a custom filter chain
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream* <i>strm</i></td>
<td valign=top>Pointer to properly prepared lzma_stream</td></tr>
<tr><td valign=top>lzma_filter* <i>filters</i></td>
<td valign=top>Array of <i>filters</i>. This must be terminated with
                      <i>filters</i>[n].id = LZMA_VLI_UNKNOWN. See filter.h for
                      more information.</td></tr>
<tr><td valign=top>lzma_check <i>check</i></td>
<td valign=top>Type of the integrity <i>check</i> to calculate from
                      uncompressed data.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Initialization was successful.
              - LZMA_MEM_ERROR
              - LZMA_OPTIONS_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_alone_encoder"></a><span class="ddoc_psymbol">lzma_alone_encoder</span>(lzma_stream* <i>strm</i>, const lzma_options_lzma* <i>options</i>);
</dt>
<dd>Initialize .lzma encoder (legacy file format)
<p></p>
The .lzma format is sometimes called the LZMA_Alone format, which is the
 reason for the name of this function. The .lzma format supports only the
 LZMA1 filter. There is no support for integrity checks like CRC32.
<p></p>

 Use this function if and only if you need to create files readable by
 legacy LZMA tools such as LZMA Utils 4.32.x. Moving to the .xz format
 is strongly recommended.
<p></p>

 The valid action values for lzma_code() are LZMA_RUN and LZMA_FINISH.
 No kind of flushing is supported, because the file format doesn't make
 it possible.

<p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_MEM_ERROR
              - LZMA_OPTIONS_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">size_t <a name="lzma_stream_buffer_bound"></a><span class="ddoc_psymbol">lzma_stream_buffer_bound</span>(size_t <i>uncompressed_size</i>);
</dt>
<dd>Calculate output buffer size for single-call Stream encoder
<p></p>
When trying to compress uncompressible data, the encoded size will be
 slightly bigger than the input data. This function calculates how much
 output buffer space is required to be sure that lzma_stream_buffer_encode()
 doesn't return LZMA_BUF_ERROR.
<p></p>

 The calculated value is not exact, but it is guaranteed to be big enough.
 The actual maximum output space required may be slightly smaller (up to
 about 100 bytes). This should not be a problem in practice.
<p></p>

 If the calculated maximum size doesn't fit into size_t or would make the
 Stream grow past LZMA_VLI_MAX (which should never happen in practice),
 zero is returned to indicate the error.

<p></p>
<b>Note:</b><br>
The limit calculated by this function applies only to
              single-call encoding. Multi-call encoding may (and probably
              will) have larger maximum expansion when encoding
              uncompressible data. Currently there is no function to
              calculate the maximum expansion of multi-call encoding.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_stream_buffer_encode"></a><span class="ddoc_psymbol">lzma_stream_buffer_encode</span>(lzma_filter* <i>filters</i>, lzma_check <i>check</i>, lzma_allocator* <i>allocator</i>, const(ubyte)* <i>in_</i>, size_t <i>in_size</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Single-call .xz Stream encoder
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_filter* <i>filters</i></td>
<td valign=top>Array of <i>filters</i>. This must be terminated with
                          <i>filters</i>[n].id = LZMA_VLI_UNKNOWN. See filter.h
                          for more information.</td></tr>
<tr><td valign=top>lzma_check <i>check</i></td>
<td valign=top>Type of the integrity <i>check</i> to calculate from
                          uncompressed data.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>lzma_allocator for custom <i>allocator</i> functions.
                          Set to NULL to use malloc() and free().</td></tr>
<tr><td valign=top>const(ubyte)* <i>in_</i></td>
<td valign=top>Beginning of the input buffer</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>Size of the input buffer</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>The next byte will be written to out[*<i>out_pos</i>].
                          *<i>out_pos</i> is updated only if encoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>Size of the out buffer; the first byte into
                          which no data is written to is out[<i>out_size</i>].</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Encoding was successful.
              - LZMA_BUF_ERROR: Not enough output buffer space.
              - LZMA_OPTIONS_ERROR
              - LZMA_MEM_ERROR
              - LZMA_DATA_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">uint <a name="LZMA_TELL_NO_CHECK"></a><span class="ddoc_psymbol">LZMA_TELL_NO_CHECK</span>;
</dt>
<dd>Decoding *
 
<p></p>

 This flag makes lzma_code() return LZMA_NO_CHECK if the input stream
 being decoded has no integrity check. Note that when used with
 lzma_auto_decoder(), all .lzma files will trigger LZMA_NO_CHECK
 if <a name="LZMA_TELL_NO_CHECK"></a><span class="ddoc_psymbol">LZMA_TELL_NO_CHECK</span> is used.<p></p>

</dd>
<dt class="d_decl">uint <a name="LZMA_TELL_UNSUPPORTED_CHECK"></a><span class="ddoc_psymbol">LZMA_TELL_UNSUPPORTED_CHECK</span>;
</dt>
<dd>This flag makes lzma_code() return LZMA_UNSUPPORTED_CHECK if the input
 stream has an integrity check, but the type of the integrity check is not
 supported by this liblzma version or build. Such files can still be
 decoded, but the integrity check cannot be verified.<p></p>

</dd>
<dt class="d_decl">uint <a name="LZMA_TELL_ANY_CHECK"></a><span class="ddoc_psymbol">LZMA_TELL_ANY_CHECK</span>;
</dt>
<dd>This flag makes lzma_code() return LZMA_GET_CHECK as soon as the type
 of the integrity check is known. The type can then be got with
 lzma_get_check().<p></p>

</dd>
<dt class="d_decl">uint <a name="LZMA_CONCATENATED"></a><span class="ddoc_psymbol">LZMA_CONCATENATED</span>;
</dt>
<dd>This flag enables decoding of concatenated files with file formats that
 allow concatenating compressed files as is. From the formats currently
 supported by liblzma, only the .xz format allows concatenated files.
 Concatenated files are not allowed with the legacy .lzma format.
<p></p>
This flag also affects the usage of the `action' argument for lzma_code().
 When <a name="LZMA_CONCATENATED"></a><span class="ddoc_psymbol">LZMA_CONCATENATED</span> is used, lzma_code() won't return LZMA_STREAM_END
 unless LZMA_FINISH is used as `action'. Thus, the application has to set
 LZMA_FINISH in the same way as it does when encoding.
<p></p>

 If <a name="LZMA_CONCATENATED"></a><span class="ddoc_psymbol">LZMA_CONCATENATED</span> is not used, the decoders still accept LZMA_FINISH
 as `action' for lzma_code(), but the usage of LZMA_FINISH isn't required.<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_stream_decoder"></a><span class="ddoc_psymbol">lzma_stream_decoder</span>(lzma_stream* <i>strm</i>, ulong <i>memlimit</i>, uint <i>flags</i>);
</dt>
<dd>Initialize .xz Stream decoder
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream* <i>strm</i></td>
<td valign=top>Pointer to properly prepared lzma_stream</td></tr>
<tr><td valign=top>ulong <i>memlimit</i></td>
<td valign=top>Memory usage limit as bytes. Use UINT64_MAX
                          to effectively disable the limiter.</td></tr>
<tr><td valign=top>uint <i>flags</i></td>
<td valign=top>Bitwise-or of zero or more of the decoder <i>flags</i>:
                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,
                          LZMA_TELL_ANY_CHECK, LZMA_CONCATENATED</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Initialization was successful.
              - LZMA_MEM_ERROR: Cannot allocate memory.
              - LZMA_OPTIONS_ERROR: Unsupported <i>flags</i>
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_auto_decoder"></a><span class="ddoc_psymbol">lzma_auto_decoder</span>(lzma_stream* <i>strm</i>, ulong <i>memlimit</i>, uint <i>flags</i>);
</dt>
<dd>Decode .xz Streams and .lzma files with autodetection
<p></p>
This decoder autodetects between the .xz and .lzma file formats, and
 calls lzma_stream_decoder() or lzma_alone_decoder() once the type
 of the input file has been detected.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>lzma_stream* <i>strm</i></td>
<td valign=top>Pointer to properly prepared lzma_stream</td></tr>
<tr><td valign=top>ulong <i>memlimit</i></td>
<td valign=top>Memory usage limit as bytes. Use UINT64_MAX
                          to effectively disable the limiter.</td></tr>
<tr><td valign=top>uint <i>flags</i></td>
<td valign=top>Bitwise-or of <i>flags</i>, or zero for no <i>flags</i>.</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Initialization was successful.
              - LZMA_MEM_ERROR: Cannot allocate memory.
              - LZMA_OPTIONS_ERROR: Unsupported <i>flags</i>
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_alone_decoder"></a><span class="ddoc_psymbol">lzma_alone_decoder</span>(lzma_stream* <i>strm</i>, ulong <i>memlimit</i>);
</dt>
<dd>Initialize .lzma decoder (legacy file format)
<p></p>
Valid `action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH.
 There is no need to use LZMA_FINISH, but allowing it may simplify
 certain types of applications.

<p></p>
<b>Returns:</b><br>- LZMA_OK
              - LZMA_MEM_ERROR
              - LZMA_PROG_ERROR<p></p>

</dd>
<dt class="d_decl">lzma_ret <a name="lzma_stream_buffer_decode"></a><span class="ddoc_psymbol">lzma_stream_buffer_decode</span>(ulong* <i>memlimit</i>, uint <i>flags</i>, lzma_allocator* <i>allocator</i>, const(ubyte)* <i>in_</i>, uint* <i>in_pos</i>, size_t <i>in_size</i>, ubyte* <i>out_</i>, uint* <i>out_pos</i>, size_t <i>out_size</i>);
</dt>
<dd>Single-call .xz Stream decoder
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>ulong* <i>memlimit</i></td>
<td valign=top>Pointer to how much memory the decoder is allowed
                          to allocate. The value pointed by this pointer is
                          modified if and only if LZMA_MEMLIMIT_ERROR is
                          returned.</td></tr>
<tr><td valign=top>uint <i>flags</i></td>
<td valign=top>Bitwise-or of zero or more of the decoder <i>flags</i>:
                          LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK,
                          LZMA_CONCATENATED. Note that LZMA_TELL_ANY_CHECK
                          is not allowed and will return LZMA_PROG_ERROR.</td></tr>
<tr><td valign=top>lzma_allocator* <i>allocator</i></td>
<td valign=top>lzma_allocator for custom <i>allocator</i> functions.
                          Set to NULL to use malloc() and free().</td></tr>
<tr><td valign=top>const(ubyte)* <i>in_</i></td>
<td valign=top>Beginning of the input buffer</td></tr>
<tr><td valign=top>uint* <i>in_pos</i></td>
<td valign=top>The next byte will be read from in[*<i>in_pos</i>].
                          *<i>in_pos</i> is updated only if decoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>in_size</i></td>
<td valign=top>Size of the input buffer; the first byte that
                          won't be read is in[<i>in_size</i>].</td></tr>
<tr><td valign=top>ubyte* <i>out_</i></td>
<td valign=top>Beginning of the output buffer</td></tr>
<tr><td valign=top>uint* <i>out_pos</i></td>
<td valign=top>The next byte will be written to out[*<i>out_pos</i>].
                          *<i>out_pos</i> is updated only if decoding succeeds.</td></tr>
<tr><td valign=top>size_t <i>out_size</i></td>
<td valign=top>Size of the out buffer; the first byte into
                          which no data is written to is out[<i>out_size</i>].</td></tr>
</table><p></p>
<b>Returns:</b><br>- LZMA_OK: Decoding was successful.
              - LZMA_FORMAT_ERROR
              - LZMA_OPTIONS_ERROR
              - LZMA_DATA_ERROR
              - LZMA_NO_CHECK: This can be returned only if using
                the LZMA_TELL_NO_CHECK flag.
              - LZMA_UNSUPPORTED_CHECK: This can be returned only if using
                the LZMA_TELL_UNSUPPORTED_CHECK flag.
              - LZMA_MEM_ERROR
              - LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.
                The minimum required <i>memlimit</i> value was stored to *<i>memlimit</i>.
              - LZMA_BUF_ERROR: Output buffer was too small.
              - LZMA_PROG_ERROR<p></p>

</dd>
</dl>

    
</div>


<div id="copyright">
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
